<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Refactor&#39;s Blog</title>
  
  <subtitle>Major in full stack especially node.js backend and share knowledge with everyone</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tecknight.xyz/"/>
  <updated>2017-10-18T12:17:48.000Z</updated>
  <id>http://tecknight.xyz/</id>
  
  <author>
    <name>Tecker.Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文讲透koa-源码剖析</title>
    <link href="http://tecknight.xyz/2017/10/17/%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8Fkoa-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://tecknight.xyz/2017/10/17/一文讲透koa-源码剖析/</id>
    <published>2017-10-17T14:59:20.000Z</published>
    <updated>2017-10-18T12:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文从头开始由浅入深剖析现在十分流行的koa框架的核心源码，适合已经熟练掌握koa框架使用的开发人员阅读</p><h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><p>现在，让我们从头开始看看koa的内部究竟做了些什么？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// usage</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>proxy <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>middleware <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subdomainOffset <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>env <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">||</span> <span class="token string">'development'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>request <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>response <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这就是一切的起源，<code>Koa</code> 类的实例从此诞生，继承自 <code>Events</code>，可得知其子类拥有处理异步事件的能力，然而<code>Koa</code>如何处理，现在还不得而知，先打个问号。但创建实例的过程中，可得知有三个对象作为实例的属性被初始化，分别为 <code>context</code> <code>request</code> <code>response</code>，还有我们非常熟悉的存放所有全局中间件的数组<code>middleware</code></p><h4 id="koa-class-图示"><a href="#koa-class-图示" class="headerlink" title="koa class 图示"></a>koa class 图示</h4><img src="/2017/10/17/一文讲透koa-源码剖析/koa.png" alt="koa.png" title=""><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// usage </span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中间件函数</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当调用use方法时，在确认它是<code>async</code>函数的情况下，通过<code>push</code>操作，这个函数会被追加到<code>middleware</code>数组中</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">use</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 类型检查...</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>此时我们已经有了处理的操作，但是<code>koa</code>还并没有真正的跑起来</p><pre class=" language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以说当开启<code>http</code>服务器的时候，<code>koa</code>才真正能够开始处理我们的<code>http</code>请求，那么这样一个简洁的调用背后具体究竟做了什么呢？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>koa</code> 使用了 <code>node</code> 的原生 <code>http</code>包来创建<code>http服务</code>,所有的秘密都藏匿在 <code>callback()</code> 这个方法中</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>koa</code> 自身还依赖于 <code>koa-compose</code> 模块，从 <code>koa</code>对于 <code>fn</code> 的使用情况来看，<code>middleware</code> 应该是被封装成了一个叫做 <code>fn</code> 的对象，通过传入 <code>context</code> 对象来返回一个 <code>Promise</code></p><p>现在，深入 <code>koa-compose</code> 模块来看看它又对我们的中间件数组做了什么。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// last called middleware #</span>  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">function</span> dispatch <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> index<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'next() called multiple times'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    index <span class="token operator">=</span> i    <span class="token keyword">let</span> fn <span class="token operator">=</span> middleware<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> middleware<span class="token punctuation">.</span>length<span class="token punctuation">)</span> fn <span class="token operator">=</span> next    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 递归结束</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token keyword">function</span> next <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 递归调用dispatch</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>里面的闭包看起来很眼熟是吗？再对比一下</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// usage </span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中间件函数</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里的 <code>Promise.resolve(fn(..))</code> 帮助我们异步执行的中间件函数，这里的<code>next</code>函数就解释了为什么<code>Koa</code>的中间件调用是递归执行的，它递归调用了 <code>dispatch</code> 函数来遍历数组中的，同时，所有的中间件函数享有同一个 <code>ctx</code>，再回顾一次外部</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> handleRequest <span class="token operator">=</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> onerror <span class="token operator">=</span> err <span class="token operator">=</span><span class="token operator">></span> ctx<span class="token punctuation">.</span><span class="token function">onerror</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> handleResponse <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">respond</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">onFinished</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> onerror<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">return</span> handleRequest<span class="token punctuation">;</span></code></pre><p><code>context</code> 使用node原生的 <code>http</code> 的监听回调函数中的 <code>req</code> <code>res</code> 来进行进一步的封装，意味着对于每一个 <code>http</code> 请求，<code>koa</code>都会创建一个 <code>context</code> 并共享给所有的全局中间件使用，当所有的中间件执行完过后，会将最后要返回的所有数据统一再交还给 <code>res</code> 进行返回，所以我们在每一个中间件中才能够从 <code>ctx</code> 中取得自己所需要的 <code>req</code> 中的数据进行处理，最后 <code>ctx</code> 再把要返回的 <code>body</code> 给原生的 <code>res</code> 进行返回</p><p>每一个请求都有唯一一个 <code>context</code> 对象，所有的关于请求和返回的东西都统一放在里面</p><p><code>createContext</code> 方法将 <code>req</code> <code>res</code> 进一步封装</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token keyword">const</span> context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个对象，使之拥有context的原型方法，后面以此类推</span><span class="token keyword">const</span> request <span class="token operator">=</span> context<span class="token punctuation">.</span>request <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> response <span class="token operator">=</span> context<span class="token punctuation">.</span>response <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span>app <span class="token operator">=</span> request<span class="token punctuation">.</span>app <span class="token operator">=</span> response<span class="token punctuation">.</span>app <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span>req <span class="token operator">=</span> request<span class="token punctuation">.</span>req <span class="token operator">=</span> response<span class="token punctuation">.</span>req <span class="token operator">=</span> req<span class="token punctuation">;</span>context<span class="token punctuation">.</span>res <span class="token operator">=</span> request<span class="token punctuation">.</span>res <span class="token operator">=</span> response<span class="token punctuation">.</span>res <span class="token operator">=</span> res<span class="token punctuation">;</span>request<span class="token punctuation">.</span>ctx <span class="token operator">=</span> response<span class="token punctuation">.</span>ctx <span class="token operator">=</span> context<span class="token punctuation">;</span>request<span class="token punctuation">.</span>response <span class="token operator">=</span> response<span class="token punctuation">;</span>response<span class="token punctuation">.</span>request <span class="token operator">=</span> request<span class="token punctuation">;</span></code></pre><p>本着一个请求一个<code>context</code>的原则，<code>context</code> 必须是作为一个临时对象而存在，所有的东西都必须封进一个对象中，因此 <code>app</code> <code>req</code> <code>res</code> 三个属性就此诞生，但不知道大家是否有一个疑问，为什么 <code>app</code> <code>req</code> <code>res</code> 也同时被封在了 <code>request</code> 和 <code>response</code> 里 ？</p><p>使他们同时共享同一个 <code>app</code> <code>req</code> <code>res</code> 和 <code>ctx</code>，是为了将处理职责进行转移，客户从外部访问，他们只需要一个 <code>ctx</code> 即可获得所有 <code>koa</code> 提供的数据和方法，而 <code>koa</code> 会继续将这些职责进行进一步的划分，比如 <code>request</code> 是用来进一步封装 <code>req</code> 的，<code>response</code> 是用来进一步封装 <code>res</code>的，这样职责得到了分散，降低了耦合，同时共享所有资源使得整个 <code>context</code> 具有了高内聚的性质，内部元素互相都能够访问得到</p><pre><code>// source codecontext.state = {};</code></pre><p>看得出来，其中的 <code>state</code> 就是专门负责保存单个请求状态的空对象，用户可以根据自己的需要来管理里面的内容</p><pre><code>// source codeconst ctx = this.createContext(req, res);const onerror = err =&gt; ctx.onerror(err);</code></pre><p>这个巨大的 <code>ctx</code> 被创建出来的时候在一开始就立马挂载了错误监听器，但在 <code>createContext</code> 中并没有发现这个<code>onerror</code>方法，应该属于其中一个模块的原型方法，经过一番搜索，发现它位于 <code>context.js</code> 这个文件下，这个文件定义了所有的默认 <code>context</code> 对象具有的原型方法</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// application.js</span><span class="token comment" spellcheck="true">// handleRequest()</span><span class="token keyword">const</span> onerror <span class="token operator">=</span> err <span class="token operator">=</span><span class="token operator">></span> ctx<span class="token punctuation">.</span><span class="token function">onerror</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">onFinished</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> onerror<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>异步函数运行过程中如果有异常抛出且内部没有自行捕获异常的话， <code>koa</code> 会统一使用 <code>Promise</code> 的<code>catch</code> 语句来进行错误处理，用一个图来表示的话那就是这样</p><h4 id="koa-请求处理流程图"><a href="#koa-请求处理流程图" class="headerlink" title="koa 请求处理流程图"></a>koa 请求处理流程图</h4><img src="/2017/10/17/一文讲透koa-源码剖析/koa-request-process.png" alt="koa-request-process.png" title=""><p>到这里我们应该也不难解开本文开头时我们心中的一个疑问，那就是为什么要继承 <code>Events</code>，其实就是为了使用 <code>node</code> 自带的事件监听器来监听一些事件，例如目前所知的 <code>error</code> ，来解耦错误处理这一块的功能</p><p>全局的错误处理函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token comment" spellcheck="true">// application.js</span><span class="token function">onerror</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">assert</span><span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`non-error thrown: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>err<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">404</span> <span class="token operator">==</span> err<span class="token punctuation">.</span>status <span class="token operator">||</span> err<span class="token punctuation">.</span>expose<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>silent<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> msg <span class="token operator">=</span> err<span class="token punctuation">.</span>stack <span class="token operator">||</span> err<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^/gm</span><span class="token punctuation">,</span> <span class="token string">'  '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Koa</code> 的内部核心处理流程已经梳理完毕，现在我们再进入内部模块一探究竟</p><h3 id="request-模块"><a href="#request-模块" class="headerlink" title="request 模块"></a>request 模块</h3><p>大量的 <code>getter</code> <code>setter</code> 充分提取出 <code>node</code> <code>http</code> 所提供的有用的请求相关的属性，还有一些必要的 <code>helper</code> 函数这里不再赘述，API文档中几乎所有的 <code>ctx.req</code> 下的属性都在其下提供，值得一提的是其中的 <code>this</code> ，头疼的 <code>this</code> , 这一块的代码用了大量的 <code>this.req</code> 的方式来访问node原生提供的 http 请求信息(因为我们把 node 的<code>req</code>赋给了<code>context</code>)，当在 <code>koa</code> 外部进行使用时我们是通过 <code>ctx.req.propertyName</code> 的形式 … 没错，我想你也发现了，我们需要绑定我们的 <code>this</code> 使之指向的是 <code>ctx.req</code>，所以在 <code>context.js</code> 模块中使用了代理来将 <code>this</code> 进行正确的绑定，前文提到的使这些模块能够相互访问的赋值代码其实也一定程度减少了<code>this</code>的麻烦事</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 详见 delegates 包</span><span class="token comment" spellcheck="true">// https://github.com/tj/node-delegates</span><span class="token comment" spellcheck="true">// Koa context.js</span><span class="token function">delegate</span><span class="token punctuation">(</span>proto<span class="token punctuation">,</span> <span class="token string">'request'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">'acceptsLanguages'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">'acceptsEncodings'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token string">'query'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">(</span><span class="token string">'origin'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// delegates 的内部核心实现，通过apply来重新绑定this</span>proto<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="response-模块"><a href="#response-模块" class="headerlink" title="response 模块"></a>response 模块</h3><p><code>response.js</code> 的内部也同 <code>request.js</code> 中类似，值得一提的是 <code>writable</code> 这个getter，如果请求已经得到相应，那么返回 <code>true</code>，其中读取的值是 <code>this.res.finished</code>，许多的报错中我们常常会碰到关于尝试重复写入响应头 <code>header</code> 的错误，这个错误的来源即使是 <code>on-finished</code> 这个包，当结束响应的时候此包能够执行一个回调来保存此请求的状态于 <code>res</code></p><h3 id="response-helper-函数"><a href="#response-helper-函数" class="headerlink" title="response helper 函数"></a>response helper 函数</h3><p>koa有一个统一的响应函数位于 <code>application.js</code> 的末尾，专门负责处理 <code>ctx.body</code> <code>ctx.status</code> 来进行请求响应</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// responses</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Buffer<span class="token punctuation">.</span><span class="token function">isBuffer</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'string'</span> <span class="token operator">==</span> <span class="token keyword">typeof</span> body<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>body <span class="token keyword">instanceof</span> <span class="token class-name">Stream</span><span class="token punctuation">)</span> <span class="token keyword">return</span> body<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// body: json</span>body <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">.</span>headersSent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ctx<span class="token punctuation">.</span>length <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">byteLength</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>值得注意的是返回的body支持 <code>Buffer</code> <code>string</code> 流，以及最常见的 <code>json</code></p><h4 id="全文完"><a href="#全文完" class="headerlink" title="全文完"></a>全文完</h4><p><strong>商业转载请联系作者获得授权，非商业转载请注明出处，谢谢合作！</strong></p><p>联系方式：tecker_yuknigh@163.com</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文从头开始由浅入深剖析现在十分流行的koa框架的核心源码，适合已经熟练掌握koa框架使用的开发人员阅读&lt;/p&gt;
&lt;h3 id=&quot;核心机制&quot;
      
    
    </summary>
    
      <category term="Node" scheme="http://tecknight.xyz/categories/Node/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="源码分析" scheme="http://tecknight.xyz/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="koa" scheme="http://tecknight.xyz/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>常见设计模式概要及其实践-TypeScript实现</title>
    <link href="http://tecknight.xyz/2017/10/15/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A6%81%E5%8F%8A%E5%85%B6%E5%AE%9E%E8%B7%B5-TypeScript%E5%AE%9E%E7%8E%B0/"/>
    <id>http://tecknight.xyz/2017/10/15/常见设计模式概要及其实践-TypeScript实现/</id>
    <published>2017-10-15T02:29:16.000Z</published>
    <updated>2017-10-15T04:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>若有不足或纰漏，欢迎指教</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>得益于TypeScript强大灵活的OOP语法，使得在js中使用经典且可靠的OOP设计模式变成了现实，虽然有的公司已经在大规模地使用TS进行中大型项目的开发，但极少有项目真正充分发挥了TS健全的OO语法优势，Java like 的OOP语法使其在思想上与Java的设计模式几乎无异，本文选取了一些常见且重要的设计模式进行提炼总结，避免探讨OOP与函数式编程孰优孰劣，模式的具体实现均采用TS进行编写，文末有彩蛋哦。</p><p>本文所有实战代码示例的<a href="https://github.com/yujiahaol68/design-pattern-learning-ts" target="_blank" rel="external">GitHub仓库地址</a>，欢迎Star</p><p>使用设计模式的意义：库与框架无法帮助我们将应用组织成容易了解，容易维护，具有弹性的架构，所以需要设计模式</p><h3 id="基本设计原则："><a href="#基本设计原则：" class="headerlink" title="基本设计原则："></a>基本设计原则：</h3><ul><li>封装变化</li><li>多用组合，少用继承</li><li>想到系统以后可能需要的变化以及应付变化的原则</li><li>针对接口编程，不针对实现编程</li><li>为了交互对象之间的松耦合设计而努力</li><li>松耦合的目的在于把对象依赖降到最低，增强系统的弹性</li><li>类应该对扩展开放，对修改关闭（开闭原则）</li><li>依赖抽象，不要依赖具体类</li><li>依赖反转原则：变量不可以持有具体类的引用，不要让类派生自具体类，不要覆盖基类中已实现的方法（子类应共享），不大会改变的对象可以违反，变化的对象可以使用工厂封装变化</li><li>最少知识原则：设计过程中不要让过多的类耦合在一起，使得尽可能少的类在一起交互</li><li>对象方法内只应调用对象本身的方法，或参数传进来对象的方法，或此方法创建的任何对象，或对象内的组件的方法（如果调用其它方法返回的是对象，不要调用其方法）</li><li>采用原则之前应全盘考虑所有因素</li><li>高层组件可以自行决定何时让低层组件参与，但低层组件不可以直接调用高层组件（在一些情况下也可以但绝不能形成环形依赖）</li><li>一个职责只指派给一个类，当它被设计成支持一组相关功能时，就具有了高内聚</li><li>上述所有的原则并非工程中的金科玉律，实际情况需要我们不断地平衡和取舍</li></ul><h3 id="策略模式-Strategy-pattern"><a href="#策略模式-Strategy-pattern" class="headerlink" title="策略模式 Strategy pattern"></a>策略模式 Strategy pattern</h3><p>核心步骤是把类1中多变的不同种行为委托封装进一个个的行为类中，行为类1.2.3..将实现各自的同一接口的不同变种并以属性的形式存在于各个类1的相似类中，使算法变化独立于使用算法的客户</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>可以随时扩充新的行为</li><li>同一个类可以通过setter动态地改变它的行为</li></ol><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/strategy/main.ts" target="_blank" rel="external">Strategy</a></p><h3 id="观察者模式-Observer-pattern"><a href="#观察者模式-Observer-pattern" class="headerlink" title="观察者模式 Observer pattern"></a>观察者模式 Observer pattern</h3><p>用于更好描述对象之间一对多的关系，当多个对象（观察者）依赖于一个对象（主题）的状态变化时，观察者模式可以帮助我们进行状态分发，将更新发送到各个观察者中，并使这两者松耦合</p><h4 id="核心步骤："><a href="#核心步骤：" class="headerlink" title="核心步骤："></a>核心步骤：</h4><p>主题类实现Observable接口，类中实现了对观察者的管理和对是否推送数据的判断，观察者类实现Observer接口，实现其中包含update方法供主题类调用，当注册新的观察者时，主题对象会将观察者对象存在观察者数组中，推送数据时遍历数组调用update方法，将数据传入其观察者对象中</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/observer/main.ts" target="_blank" rel="external">Observer</a></p><h3 id="装饰者模式-Decorator-pattern"><a href="#装饰者模式-Decorator-pattern" class="headerlink" title="装饰者模式 Decorator pattern"></a>装饰者模式 Decorator pattern</h3><p>动态的赋予已有对象新的职责，比继承更具弹性，其中有使用到继承，但只是利用继承来达到类型匹配超类而不获得行为，行为来自于装饰者和基础组件或与其它装饰者的组合。</p><p>作为设计模式届的多米诺，每个新的被装饰者都不仅包含着上一个装饰者的状态而且还可以扩展自己的属性，通过共同的超类使得状态的共性得以保存且能够进行向上层级的链式调用，可以近似看做子类递归调用父类，使用此模式可以很好的替代继承</p><h4 id="核心步骤：-1"><a href="#核心步骤：-1" class="headerlink" title="核心步骤："></a>核心步骤：</h4><p>被装饰类统一派生自一个超抽象类A获得其类型，装饰抽象类B继承A，并在构造函数中保存A类型的对象的所有状态，每一个新的装饰者包装上一次的被装饰者，被装饰类在被装饰之后仍可不断地被扩展</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>客户代码不能依赖特殊类型，会出现许多小对象，过度使用会导致程序复杂</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/decorator/main.ts" target="_blank" rel="external">Decorator</a></p><h3 id="工厂模式-Factory-pattern"><a href="#工厂模式-Factory-pattern" class="headerlink" title="工厂模式 Factory pattern"></a>工厂模式 Factory pattern</h3><p>制造对象和解决耦合的好办法，严格来讲这并非一种模式而是一种编码习惯，将派生类的实例化封装在工厂类的静态方法中，抽象工厂方法可以让子类自行决定制造方式，在外部我们调用的抽象方法具有很大的弹性，实现可以不用绑定具体的类，这就得到了另外一个好处：使得超类和子类对象的代码解耦。而且能够将实例化延迟至子类中进行</p><h4 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h4><p>对需要弹性的方法使用抽象工厂方法来替代，想要使得产品可定制，可以将产品类定义成抽象类并提供一些默认的属性和方法或抽象方法，派生类可以自行进行覆盖重写或自行实现，不同的工厂类可以隐藏不同的产品的制造细节但却保留着相同的制作流程</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/factory/simple.ts" target="_blank" rel="external">Simple Factory</a></p><h4 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂 Abstract Factory"></a>抽象工厂 Abstract Factory</h4><p>不同的工厂类实现同一抽象工厂接口制造相似的产品，相似的产品再依赖于产品共同的接口来使得客户无须关心实际产出的具体产品就能使用</p><p>二者区别在于工厂方法委托子类来实例化对象，而抽象工厂建立了产品与客户的接口契约，两者都可以把客户从具体产品中解耦出来</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/factory/abstract.ts" target="_blank" rel="external">Abstract Factory</a></p><h3 id="单例模式-Singleton-pattern"><a href="#单例模式-Singleton-pattern" class="headerlink" title="单例模式 Singleton pattern"></a>单例模式 Singleton pattern</h3><p>实例化唯一一个对象，提供一个全局访问点，所有设计模式中最简单但非常实用且用途广泛</p><h4 id="核心要点："><a href="#核心要点：" class="headerlink" title="核心要点："></a>核心要点：</h4><p>把一个静态私有变量确立为唯一的实例，外部通过静态方法访问这个唯一的实例，并把构造函数设为私有</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/singleton/main.ts" target="_blank" rel="external">Singleton</a></p><h3 id="命令模式-Command-pattern"><a href="#命令模式-Command-pattern" class="headerlink" title="命令模式 Command pattern"></a>命令模式 Command pattern</h3><p>封装请求引入中间代理对象，将动作的请求者从动作的执行者中解耦出来，常用于工作队列或大型数据结构的操作记录以及事务处理</p><h4 id="核心步骤：-2"><a href="#核心步骤：-2" class="headerlink" title="核心步骤："></a>核心步骤：</h4><p>具体任务执行细节封装于Command接口的execute方法的实现中，然后将实现接口的类的实例传递给它的客户，再由客户通过调用其execute方法来执行</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/command/main.ts" target="_blank" rel="external">Command</a></p><h3 id="适配器模式-Adapter-pattern"><a href="#适配器模式-Adapter-pattern" class="headerlink" title="适配器模式 Adapter pattern"></a>适配器模式 Adapter pattern</h3><p>包装某些接口以实现不同的目的，转换接口使其能被其他的对象使用，改变接口符合客户的期望</p><h4 id="核心要点：-1"><a href="#核心要点：-1" class="headerlink" title="核心要点："></a>核心要点：</h4><p>对象适配器类实现目标接口并在其中调用待适配的对象的对应方法，使得在客户代码不变的前提下可以调用不同接口的对象</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/adapter/main.ts" target="_blank" rel="external">Adapter</a></p><h3 id="外观模式-Facade-pattern"><a href="#外观模式-Facade-pattern" class="headerlink" title="外观模式 Facade pattern"></a>外观模式 Facade pattern</h3><p>使用外观类Facade简化接口，封装复杂的子系统，并暴露出更少的更简单的接口，打造更高层的功能，针对外观编程可以使得客户与子系统的组件解耦</p><h4 id="核心要点：-2"><a href="#核心要点：-2" class="headerlink" title="核心要点："></a>核心要点：</h4><p>构造Facade类的时候集合子系统的各个组件对象，暴露出的接口提供更直接更高层的操作，契合最少知识原则</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/facade/main.ts" target="_blank" rel="external">Facade</a></p><h3 id="模板方法模式-Template-Method-pattern"><a href="#模板方法模式-Template-Method-pattern" class="headerlink" title="模板方法模式 Template Method pattern"></a>模板方法模式 Template Method pattern</h3><p>这种封装方式可以使得子类在任何时候都可以将自己挂载进运算里，模板方法定义了一个算法步骤，并允许子类为其中的部分步骤提供自己的实现</p><h4 id="核心要点：-3"><a href="#核心要点：-3" class="headerlink" title="核心要点："></a>核心要点：</h4><p>将相同的步骤抽离出来在抽象类中实现，不同的步骤在子类之中分别实现（父类中以抽象方法的形式存在），子类通过调用同一个模板方法去实现各自的功能（功能有部分不同，但单从模板方法中无法得知，因为被统一抽象了）。模板方法中可以加入钩子方法，提供默认的实现或留空以供子类进行覆盖，通过条件进行流程控制我们可以大大增加算法的灵活性，钩子方法通常是算法当中可选的一部分</p><h4 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景:"></a>常见应用场景:</h4><p>对象排序的时候对象需要先实现一个比较方法</p><h3 id="总结（踩蛋）"><a href="#总结（踩蛋）" class="headerlink" title="总结（踩蛋）"></a>总结（踩蛋）</h3><p>如果看到这里时，你仍然觉得这么多的模式使你头晕脑胀更别说应用的话，请收下这几枚硬干货：</p><ul><li>计算机科学领域的任何问题, 都可以通过添加一个中间层来解决，几乎所有的设计模式都遵循了这个原则来应对变化增加弹性或进行扩展</li><li>抽象与复用是核心需求，摸石们都为了满足这两点而不断地努力着</li><li>没有完美的模式能够完美应对所有的变化</li></ul><p>最后，希望你能够将模式多多应用到业务或编写框架中，尽最大努力编写出干净，可扩展，易维护的架构。</p><p><strong>参考资料:</strong> 《HeadFirst设计模式中文版》2007年第一版</p><p><strong>商业转载请联系作者获得授权，非商业转载请注明出处，谢谢合作！</strong></p><p>联系方式：tecker_yuknigh@163.com</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;若有不足或纰漏，欢迎指教&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h3&gt;&lt;p&gt;得益于TypeScript强大灵活的OOP语法，使得在js中使用经典且可靠的OOP设计模式变成
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://tecknight.xyz/categories/TypeScript/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="TypeScript" scheme="http://tecknight.xyz/tags/TypeScript/"/>
    
      <category term="design pattern" scheme="http://tecknight.xyz/tags/design-pattern/"/>
    
      <category term="learning" scheme="http://tecknight.xyz/tags/learning/"/>
    
  </entry>
  
  <entry>
    <title>使用sftp搭建本地快速部署环境</title>
    <link href="http://tecknight.xyz/2017/09/10/%E4%BD%BF%E7%94%A8sftp%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/"/>
    <id>http://tecknight.xyz/2017/09/10/使用sftp搭建本地快速部署环境/</id>
    <published>2017-09-10T07:11:53.000Z</published>
    <updated>2017-09-10T07:16:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先，我们要确保<code>sshd</code>也就是我们的ssh服务处于运行状态之中，下面以centos为例来讲解搭建的过程。</p><p>必要的包: <code>openssh-clients</code> <code>openssh-server</code></p><p>运行下面的命令以确定我们的ssh服务处于active的状态中</p><pre><code>$ systemctl status sshd</code></pre><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>新建一个用户(非root用户请加sudo)</p><pre><code>$ adduser test</code></pre><pre><code>$ passwd test</code></pre><p>设置密码，更新用户令牌信息，本地生成SSH密钥并将公钥放置于服务器，确保能从本地使用SSH登录远程主机</p><p>明确新用户的文件夹权限</p><pre><code>$ chown root:root /../somepath/sftp$ chmod 755 /../somepath/sftp</code></pre><p>在sftp文件夹下创建<code>uploads</code>文件夹，所有上传的文件都会在里面，将拥有者设置为test用户</p><pre><code>$ chown test:test /../somepath/sftp/uploads</code></pre><p>将<code>PasswordAuthentication</code>设置为<code>no</code>并保存，确保不能用密码建立SSH连接并重启SSH服务</p><pre><code>$ vi /etc/ssh/sshd_config$ ...$ systemctl restart sshd</code></pre><p>现在在本地尝试使用<code>sftp</code>进行登录</p><pre><code>sftp -i ~/.ssh/key test@ip_address</code></pre><p>发现进入sftp即成功！</p><h3 id="使用vscode配置快速部署环境"><a href="#使用vscode配置快速部署环境" class="headerlink" title="使用vscode配置快速部署环境"></a>使用vscode配置快速部署环境</h3><p>这里是用的是 <code>ftp-sync</code> 插件</p><p>安装完成之后按<code>F1</code>键</p><p>选择<code>Ftp-sync: init</code></p><p>就可以在<code>.vscode</code>文件夹下找到<code>ftp-sync.json</code>文件</p><pre><code>{    &quot;remotePath&quot;: &quot;/../sftp/uploads/project&quot;,    &quot;host&quot;: &quot;&quot;,    // ip地址    &quot;username&quot;: &quot;test&quot;,    &quot;password&quot;: null,    // 留空，因为使用了更安全的sftp协议传输文件    &quot;port&quot;: 22,    // SSH端口    &quot;secure&quot;: true,    &quot;protocol&quot;: &quot;sftp&quot;,    &quot;uploadOnSave&quot;: false,    &quot;passive&quot;: false,    &quot;debug&quot;: false,    &quot;privateKeyPath&quot;: &quot;/Users/user/.ssh/key&quot;,  // 本地密钥的地址    &quot;passphrase&quot;: null,    &quot;ignore&quot;: [        &quot;\\.vscode&quot;,        &quot;\\.git&quot;,        &quot;\\.DS_Store&quot;,        &quot;\\node_modules&quot;,        &quot;\\test&quot;,        &quot;\\.travis.yml&quot;        // 想要忽略上传的文件夹或文件    ],    &quot;generatedFiles&quot;: {        &quot;uploadOnSave&quot;: false,        &quot;extensionsToInclude&quot;: [],        &quot;path&quot;: &quot;&quot;    }}</code></pre><p>然后愉快地快速部署到服务器吧</p><p><code>F1</code> </p><p>选择 <code>Ftp-sync: Local To Remote</code></p><p>选择 <code>full-sync</code>，执行上传。大功告成！</p><p>注： 如果是node项目的话可以使用<code>pm2</code>检测文件更改自动重启服务，一键更新线上代码！</p><p>参考：</p><p><a href="https://www.digitalocean.com/community/tutorials/how-to-enable-sftp-without-shell-access-on-centos-7" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-enable-sftp-without-shell-access-on-centos-7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h3&gt;&lt;p&gt;首先，我们要确保&lt;code&gt;sshd&lt;/code&gt;也就是我们的ssh服务处于运行状态之中，下面以centos为例来讲解搭建的过程。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="web" scheme="http://tecknight.xyz/tags/web/"/>
    
      <category term="shell" scheme="http://tecknight.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>centOS下的node部署环境搭建</title>
    <link href="http://tecknight.xyz/2017/06/08/centOS%E4%B8%8B%E7%9A%84node%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://tecknight.xyz/2017/06/08/centOS下的node部署环境搭建/</id>
    <published>2017-06-08T08:21:41.000Z</published>
    <updated>2017-06-08T09:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文实践的是单机搭建-nginx-node-mongodb-redis-流行组合的具体过程"><a href="#本文实践的是单机搭建-nginx-node-mongodb-redis-流行组合的具体过程" class="headerlink" title="本文实践的是单机搭建 nginx+node+mongodb+redis 流行组合的具体过程"></a>本文实践的是单机搭建 nginx+node+mongodb+redis 流行组合的具体过程</h2><p><a href="https://jp.godaddy.com/help/set-up-nodejs-application-for-production-centos-17354" target="_blank" rel="external">node的安装过程详情</a></p><p>其他的直接上亲自实践过的安装命令以及需要注意的地方，习惯用英文注释，部分重点已用中文指出</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#update software</span><span class="token function">sudo</span> yum update -y<span class="token comment" spellcheck="true">#back to root dir</span><span class="token function">cd</span> ~<span class="token comment" spellcheck="true">#Nginx</span><span class="token function">sudo</span> yum -y <span class="token function">install</span> <span class="token function">make</span> zlib zlib-devel gcc-c++ libtool  openssl openssl-devel<span class="token comment" spellcheck="true">#If pcre</span>rpm -qa pcre<span class="token comment" spellcheck="true">#yes download nginx stable version</span><span class="token function">wget</span> http://nginx.org/download/nginx-1.12.0.tar.gz<span class="token function">tar</span> zxvf nginx-1.12.0.tar.gz<span class="token comment" spellcheck="true">#switch to root for mkdir</span><span class="token function">su</span> root<span class="token function">cd</span> nginx-1.12.0./configure <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span class="token function">cd</span> ~ <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span><span class="token function">rm</span> -rf nginx-1.12.0<span class="token function">rm</span> nginx-1.12.0.tar.gz<span class="token comment" spellcheck="true">#start nginx</span><span class="token comment" spellcheck="true">#access public IP should success</span>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<span class="token comment" spellcheck="true">#self-start config</span><span class="token function">sudo</span> <span class="token function">vi</span> /lib/systemd/system/nginx.service<span class="token comment" spellcheck="true">#content</span><span class="token keyword">:</span><span class="token string">'[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target'</span>systemctl start nginx.servicesystemctl <span class="token function">enable</span> nginx.service<span class="token comment" spellcheck="true">#check if running</span>systemctl list-units --type<span class="token operator">=</span>service<span class="token comment" spellcheck="true">#Mongodb</span><span class="token function">sudo</span> <span class="token function">vi</span> /etc/yum.repos.d/mongodb-org-3.4.repo<span class="token comment" spellcheck="true">#https://docs.mongodb.com/master/tutorial/install-mongodb-on-red-hat/</span><span class="token comment" spellcheck="true">#content</span><span class="token keyword">:</span><span class="token string">'[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/<span class="token variable">$releasever</span>/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc'</span><span class="token comment" spellcheck="true">#yum install mongodb</span><span class="token function">sudo</span> yum -y <span class="token function">install</span> mongodb-org<span class="token comment" spellcheck="true">#start mongodb(default it can self-start when booting)</span><span class="token function">sudo</span> <span class="token function">service</span> mongod start<span class="token comment" spellcheck="true">#self-start</span><span class="token function">sudo</span> <span class="token function">chkconfig</span> mongod on<span class="token comment" spellcheck="true">#pm2 install</span><span class="token function">sudo</span> cnpm i pm2 -g<span class="token comment" spellcheck="true">#redis</span><span class="token function">wget</span> http://download.redis.io/releases/redis-3.2.9.tar.gz<span class="token function">su</span> root<span class="token function">tar</span> xzf redis-3.2.9.tar.gz<span class="token function">cd</span> redis-3.2.9<span class="token function">make</span><span class="token function">cd</span> src<span class="token function">cp</span> redis-server redis-cli redis-sentinel redis-benchmark redis-check-aof redis-check-rdb /usr/local/bin<span class="token function">mkdir</span> /etc/redis<span class="token function">mkdir</span> -p /var/lib/redis/6379<span class="token function">cp</span> redis.conf /etc/redis/6379.conf<span class="token function">vi</span> /etc/redis/6379.conf<span class="token keyword">:</span><span class="token string">'daemonize yeslogfile /var/log/redis_6379.logdir /var/lib/redis/6379'</span><span class="token function">cp</span> utils/redis_init_script /etc/init.d/redis<span class="token function">vi</span> /lib/systemd/system/redis.service<span class="token comment" spellcheck="true">#content</span><span class="token keyword">:</span><span class="token string">'[Unit]Description=Redis on port 6379[Service]Type=forkingExecStart=/etc/init.d/redis_6379 startExecStop=/etc/init.d/redis_6379 stop[Install]WantedBy=multi-user.targetvm.overcommit_memory = 1net.core.somaxconn=512'</span>systemctl start redis.servicesystemctl <span class="token function">enable</span> redis.service<span class="token function">cd</span> <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf redis-3.2.9 redis-3.2.9.tar.gz<span class="token comment" spellcheck="true">#kernel config</span>sysctl -w vm.overcommit_memory<span class="token operator">=</span>1sysctl -w net.core.somaxconn<span class="token operator">=</span>512<span class="token keyword">echo</span> never <span class="token operator">></span> /sys/kernel/mm/transparent_hugepage/enabled<span class="token comment" spellcheck="true">#booting shell</span><span class="token keyword">echo</span> never <span class="token operator">>></span> /sys/kernel/mm/transparent_hugepage/enabled<span class="token keyword">echo</span> never <span class="token operator">>></span> /sys/kernel/mm/transparent_hugepage/defragsystemctl restart mongod.service<span class="token comment" spellcheck="true">#nginx conf ( Remember to configure user !!!)</span><span class="token comment" spellcheck="true">#nginx 配置内容经优化（踩过的坑，最顶部的注释要去掉替换成对应的用户名，否则会无文件权限！！）</span><span class="token comment" spellcheck="true">#其中含负载均衡及反向代理的配置，模仿着配置好就行</span><span class="token keyword">:</span><span class="token string">'#user userNamehttp {    client_header_buffer_size 3k;    client_max_body_size 2m;    client_body_buffer_size 7k;    large_client_header_buffers 2 1k;    client_body_timeout   32;    client_header_timeout 32;    reset_timedout_connection on;    open_file_cache max=200000 inactive=20s;    open_file_cache_valid 30s;    open_file_cache_min_uses 2;    open_file_cache_errors on;    tcp_nopush on;    tcp_nodelay on;    types_hash_max_size 2048;    gzip on;    gzip_disable "MSIE [1-6]\.";    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;    types_hash_max_size 2048;}# 负载均衡upstream pro_name {    server 127.0.0.1:3000;#   balanceServer ip2;#   balanceServer ip3;}server {    listen 80;    server_name pro_name;    charset utf-8;    access_log /var/log/nginx/app.log;    root /home/.../code/...;    location ~ /api/ {        proxy_pass http://pro_name;        proxy_redirect off;        proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span>;        proxy_set_header Host <span class="token variable">$http_host</span>;        proxy_set_header X-NginX-Proxy true;        proxy_http_version 1.1;        proxy_read_timeout 7s;    }    location ~ /.ht {        deny all;    }    location ~* \.(css|js|gif|jpe?g|png|ico)$ {        root /home/.../code/...;        expires 168h;    }    location / {        index  index.html index.htm;    }}'</span><span class="token comment" spellcheck="true">#实用nginx命令，养成好习惯</span><span class="token comment" spellcheck="true">#everytime save change of .conf</span>/usr/local/nginx/sbin/nginx -t  <span class="token comment" spellcheck="true">#Check Syntax</span>/usr/local/nginx/sbin/nginx -s reload <span class="token comment" spellcheck="true">#Smooth reload nginx</span><span class="token comment" spellcheck="true">#nginx optimize</span>sysctl -w net.core.somaxconn<span class="token operator">=</span>1024</code></pre><h3 id="最后使用pm2进行node项目的管理，包括简单的监控"><a href="#最后使用pm2进行node项目的管理，包括简单的监控" class="headerlink" title="最后使用pm2进行node项目的管理，包括简单的监控"></a>最后使用pm2进行node项目的管理，包括简单的监控</h3><p>详情请见</p><p><a href="http://pm2.keymetrics.io/" target="_blank" rel="external">pm2进程管理</a></p><p><a href="https://keymetrics.io/" target="_blank" rel="external">keymetrics监控项目</a></p><h3 id="附上腾讯云主机在生产环境下的安全组配置"><a href="#附上腾讯云主机在生产环境下的安全组配置" class="headerlink" title="附上腾讯云主机在生产环境下的安全组配置"></a>附上腾讯云主机在生产环境下的安全组配置</h3><img src="/2017/06/08/centOS下的node部署环境搭建/1.png" alt="1.png" title=""><img src="/2017/06/08/centOS下的node部署环境搭建/2.png" alt="2.png" title="">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本文实践的是单机搭建-nginx-node-mongodb-redis-流行组合的具体过程&quot;&gt;&lt;a href=&quot;#本文实践的是单机搭建-nginx-node-mongodb-redis-流行组合的具体过程&quot; class=&quot;headerlink&quot; title=&quot;本文
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="centOS" scheme="http://tecknight.xyz/tags/centOS/"/>
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="deploy" scheme="http://tecknight.xyz/tags/deploy/"/>
    
      <category term="环境搭建" scheme="http://tecknight.xyz/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>mongoose下的promise技巧</title>
    <link href="http://tecknight.xyz/2017/05/02/mongoose%E4%B8%8B%E7%9A%84promise%E6%8A%80%E5%B7%A7/"/>
    <id>http://tecknight.xyz/2017/05/02/mongoose下的promise技巧/</id>
    <published>2017-05-02T04:18:46.000Z</published>
    <updated>2017-06-08T08:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Promise大行其道的世界里，使用promise可谓是家常便饭了，写一个漂亮的promise极其重要</p><p>本文将会基于Express环境实战mongoose的promise，帮大家避免一些常见的错误并对promise链进行调整以提高其可读性</p><p>最后，本文将会介绍一种极少见的promise奇淫怪技，解决一些难以解决的又不得不解决的异步冲突</p></blockquote><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>虽然<code>mongoose</code>本身也有自带<code>promise</code>且大部分操作返回就是一个<code>promise</code>对象，但大多数情况下我们还是毅然决然的换成<code>bluebird</code>这个promise库，其中提供了大量的<br>promise操作可供我们使用，废话少说，赶紧上路！</p><h2 id="Bad-example"><a href="#Bad-example" class="headerlink" title="Bad example"></a>Bad example</h2><p>你可能看过这样的<code>Promise</code>链中链</p><pre class=" language-javascript"><code class="language-javascript">user_group<span class="token punctuation">.</span><span class="token function">findByName</span><span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">findUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>userObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">...</span><span class="token punctuation">.</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">next</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">next</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看到这里不用写都应该能发现，这<code>Promise</code>已经失去了它原本的使命，层层嵌套，犹如又回到了地狱回调的节奏，可读性不免让人觉得糟糕</p><h2 id="Let’s-pratice"><a href="#Let’s-pratice" class="headerlink" title="Let’s pratice"></a>Let’s pratice</h2><p>我们可以来动手改写一下</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续.."></a>未完待续..</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在Promise大行其道的世界里，使用promise可谓是家常便饭了，写一个漂亮的promise极其重要&lt;/p&gt;
&lt;p&gt;本文将会基于Express环境实战mongoose的promise，帮大家避免一些常见的错误并对promise链进行调整以提高其
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="promise" scheme="http://tecknight.xyz/tags/promise/"/>
    
      <category term="mongoose" scheme="http://tecknight.xyz/tags/mongoose/"/>
    
  </entry>
  
  <entry>
    <title>用supertest进行API测试</title>
    <link href="http://tecknight.xyz/2017/04/23/%E7%94%A8supertest%E8%BF%9B%E8%A1%8CAPI%E6%B5%8B%E8%AF%95/"/>
    <id>http://tecknight.xyz/2017/04/23/用supertest进行API测试/</id>
    <published>2017-04-23T00:13:51.000Z</published>
    <updated>2017-04-23T01:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在node开发中，写完了API接口之后，往往都要进行测试，现在常用的测试模块一般都是<code>mocha</code>和<code>chai</code>，<br>然后我们应该有相配合的请求模块来帮助我们更好地完成断言的工作，今天要介绍的主角就是<code>supertest</code></p><p>用过<code>superagent</code>的童鞋应该都知道，<code>supertest</code>的用法同样简洁优雅，本文环境基于<code>Express</code>，废话不说，上实战代码</p><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> assert <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'chai'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>assert<span class="token punctuation">;</span><span class="token keyword">const</span> request <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'supertest'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> should <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'should'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../../app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> _ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将supertest设成request是习惯使然</span><span class="token comment" spellcheck="true">// 断言</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"get /"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// it描述了API的功能，预期的返回内容</span>    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"should respond with ...."</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用supertest进行GET请求，并验证其返回的状态码</span>        <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'Accept'</span><span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//设置请求头</span>            <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//预期的状态码</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                assert<span class="token punctuation">.</span><span class="token function">notEqual</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>body<span class="token punctuation">,</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 使用assert断言库进行断言，如果lodash找不到json中的最外层的键值对(找里面的话可以在body的基础上继续访问)</span>                    <span class="token comment" spellcheck="true">// 使用equal或者是to.include.keys('key')也是可以的</span>                    <span class="token string">'key'</span> <span class="token punctuation">:</span> <span class="token string">'value'</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 前面不再赘述，我们专注于supertest</span><span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/search'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span> key<span class="token punctuation">:</span> <span class="token string">'value'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// x-www-form-urlencoded</span>        <span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// form-data</span>        <span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token string">'avatar'</span><span class="token punctuation">,</span> <span class="token string">'test/fixtures/homeboy.jpg'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// post上传附件</span></code></pre><h3 id="PUT或DELETE请求"><a href="#PUT或DELETE请求" class="headerlink" title="PUT或DELETE请求"></a>PUT或DELETE请求</h3><p>同理</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token string">'/path'</span><span class="token punctuation">)</span><span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'/path'</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在node开发中，写完了API接口之后，往往都要进行测试，现在常用的测试模块一般都是&lt;code&gt;mocha&lt;/code&gt;和&lt;code&gt;chai&lt;/code&gt;，&lt;br&gt;然后我们应该有相配合的请求模块来帮助我们更好地完成断言的工作，今天要介绍的主角就是&lt;code&gt;superte
      
    
    </summary>
    
      <category term="Node" scheme="http://tecknight.xyz/categories/Node/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="Express" scheme="http://tecknight.xyz/tags/Express/"/>
    
      <category term="api" scheme="http://tecknight.xyz/tags/api/"/>
    
      <category term="test" scheme="http://tecknight.xyz/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>最精简restful实现</title>
    <link href="http://tecknight.xyz/2017/04/12/%E6%9C%80%E7%B2%BE%E7%AE%80restful%E5%AE%9E%E7%8E%B0/"/>
    <id>http://tecknight.xyz/2017/04/12/最精简restful实现/</id>
    <published>2017-04-12T14:25:23.000Z</published>
    <updated>2017-04-12T14:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Time-is-short-Just-show-me-the-code"><a href="#Time-is-short-Just-show-me-the-code" class="headerlink" title="Time is short. Just show me the code!"></a>Time is short. Just show me the code!</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*附上测试方法curl -X GET http://localhost:3000curl -X POST -d "Node should test in action" http://localhost:3000curl -X DELETE http://localhost:3000/1curl -X PUT -d "Pratice node every day" http://localhost:3000/1*/</span><span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// method include POST,GET,DELETE,PUT</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">'POST'</span><span class="token punctuation">:</span>            <span class="token keyword">var</span> item <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// convert bytes to utf-8 encoding data</span>            req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// listening data event, POST data will send to server by chunk (bytes array)</span>            req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>                item <span class="token operator">+</span><span class="token operator">=</span>chunk<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'OK\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'GET'</span><span class="token punctuation">:</span>            items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">') '</span> <span class="token operator">+</span> element <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'DELETE'</span><span class="token punctuation">:</span>            <span class="token keyword">var</span> path <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>pathname<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//get string '/1'</span>            <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// convert String to Number</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Invalid item id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Item not found!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'delete success!\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'PUT'</span><span class="token punctuation">:</span>            <span class="token keyword">var</span> newItem <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> putPath <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>pathname<span class="token punctuation">;</span>            <span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>putPath<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Invalid item id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>items<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'item not found!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    newItem <span class="token operator">+</span><span class="token operator">=</span> chunk<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                items<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newItem<span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'update success!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Time-is-short-Just-show-me-the-code&quot;&gt;&lt;a href=&quot;#Time-is-short-Just-show-me-the-code&quot; class=&quot;headerlink&quot; title=&quot;Time is short. Just sh
      
    
    </summary>
    
      <category term="Node" scheme="http://tecknight.xyz/categories/Node/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="native" scheme="http://tecknight.xyz/tags/native/"/>
    
      <category term="RESTFul" scheme="http://tecknight.xyz/tags/RESTFul/"/>
    
  </entry>
  
  <entry>
    <title>python 语法基础</title>
    <link href="http://tecknight.xyz/2017/04/11/python-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://tecknight.xyz/2017/04/11/python-语法基础/</id>
    <published>2017-04-11T12:58:59.000Z</published>
    <updated>2017-04-11T13:01:01.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="其中记录了python跟别的语言不一样的一些基础知识点"><a href="#其中记录了python跟别的语言不一样的一些基础知识点" class="headerlink" title="其中记录了python跟别的语言不一样的一些基础知识点"></a>其中记录了python跟别的语言不一样的一些基础知识点</h4><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p><code>True</code></p><p><code>False</code></p><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p><code>/</code> 默认的除法是精确除法</p><p><code>//</code> 才是通常的取商的整数部分</p><h4 id="字符-类似C的ASCII码"><a href="#字符-类似C的ASCII码" class="headerlink" title="字符(类似C的ASCII码)"></a>字符(类似C的ASCII码)</h4><p><code>ord()</code> 字符对应编码</p><p><code>chr()</code> 编码转字符</p><p><code>&#39;aaa&#39;.encode(&#39;utf-8&#39;)</code> 转成对应编码形式的<code>bytes</code></p><p><code>&#39;aaa&#39;.decode(&#39;utf-8&#39;)</code> 从<code>bytes</code>转成<code>utf-8</code>编码</p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><pre class=" language-python"><code class="language-python">r <span class="token operator">=</span> <span class="token number">18.0555</span><span class="token string">'%.2f%%'</span> <span class="token operator">%</span>r<span class="token comment" spellcheck="true"># '18.06%'</span></code></pre><h4 id="数据类型之list-类比数组"><a href="#数据类型之list-类比数组" class="headerlink" title="数据类型之list(类比数组)"></a>数据类型之list(类比数组)</h4><p>获取<code>list</code>元素个数<code>len(变量名)</code></p><p>访问元素下标为负表示都是第几个元素</p><p>末尾添加元素 <code>vary.append(...)</code></p><p>插入指定位置 <code>vary.insert(1, &#39;Jack&#39;)</code></p><p>末尾元素去除 <code>vary.pop()</code></p><p>去除指定位置 <code>vary.pop(2)</code></p><p>元素之间的数据类型可不同</p><h4 id="数据类型之tuple元组"><a href="#数据类型之tuple元组" class="headerlink" title="数据类型之tuple元组"></a>数据类型之tuple元组</h4><p>与<code>list</code>相比这样定义出来的数组内的元素是不可直接变的，数据更加安全</p><p>间接改变的原理：<code>tuple是保持元素的指向不变，指向的内容是可能可变的，例如元素是list</code></p><pre class=" language-python"><code class="language-python">t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span></code></pre><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p><code>:</code> 替代花括号块</p><p><code>elif</code> 等价于其他语言的 <code>else if</code></p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><code>for-in</code> 循环    <code>for x in ...:</code></p><p><code>continue</code> 打破当前循环进入下一次循环</p><p><code>break</code> 退出循环体</p><h4 id="dict-键值对"><a href="#dict-键值对" class="headerlink" title="dict 键值对"></a>dict 键值对</h4><pre class=" language-python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">:</span><span class="token number">33</span><span class="token punctuation">}</span>d<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 22</span></code></pre><p>找不到<code>key</code>时会报错，所以查<code>key</code>之前要判断一下<code>key in d</code>的返回值再查找</p><p>或者</p><p><code>d.get(&#39;B&#39;, -1)</code> 第二个参数指定了找不到时返回的值</p><p><code>dict</code> 中的<code>key</code>不可变</p><p>删除 <code>d.pop(key)</code></p><h4 id="set-key的集合"><a href="#set-key的集合" class="headerlink" title="set key的集合"></a>set key的集合</h4><p>初始化需传入一个<code>list</code>，传入的元素不能有重复的</p><pre class=" language-python"><code class="language-python">s <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># {5, 6, 7}</span></code></pre><p>添加 <code>add(key)</code></p><p>删除 <code>remove(key)</code></p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p><code>str.remove(&#39;a&#39;, &#39;A&#39;)</code>将<code>a</code>替换成<code>A</code>但是方法会返回一个新的串，原来的<code>str</code>不可变！</p><h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><p><code>abs()</code></p><p><code>max()</code> 可以放任意个参数只返回最大</p><p><code>a = abs</code> 给<code>abs</code>函数引用发给<code>a</code>，调用<code>a()</code>效果一样</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>int(要转换的变量)</code></p><p>其他类似</p><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p><code>def</code> 替代<code>function</code></p><h4 id="缩进体置空"><a href="#缩进体置空" class="headerlink" title="缩进体置空"></a>缩进体置空</h4><p><code>pass</code></p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>居然可以有多个!! 我的三观…</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">goBack</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>    <span class="token keyword">return</span> x<span class="token punctuation">,</span>ya<span class="token punctuation">,</span>b <span class="token operator">=</span> goBack<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><p>原因：返回的是<code>tuple</code></p><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">goBack</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span>int<span class="token punctuation">,</span> float<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> x<span class="token punctuation">,</span>y<span class="token comment" spellcheck="true"># 允许int和float类型</span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">power</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># n默认值为2</span></code></pre><p><code>默认参数必须指向不变对象</code></p><p>参数可以是 <code>list</code> 或者 <code>tuble</code>，利用可变参数</p><p>可变参数 <code>def calc(*numbers):</code> 多参数自动组装成<code>tuple</code></p><p>关键字参数 <code>def person(name, age, **kw):</code> 方便扩展函数的参数</p><p><code>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</code></p><h4 id="尾递归优化递归函数"><a href="#尾递归优化递归函数" class="headerlink" title="尾递归优化递归函数"></a>尾递归优化递归函数</h4><p><code>指在函数返回的时候，调用自身本身，并且，return语句不能包含表达式</code></p><p>注意：标准解释器并不支持这种用法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;其中记录了python跟别的语言不一样的一些基础知识点&quot;&gt;&lt;a href=&quot;#其中记录了python跟别的语言不一样的一些基础知识点&quot; class=&quot;headerlink&quot; title=&quot;其中记录了python跟别的语言不一样的一些基础知识点&quot;&gt;&lt;/a&gt;其中记录了
      
    
    </summary>
    
      <category term="python" scheme="http://tecknight.xyz/categories/python/"/>
    
    
      <category term="python" scheme="http://tecknight.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习的常用概念</title>
    <link href="http://tecknight.xyz/2017/04/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/"/>
    <id>http://tecknight.xyz/2017/04/08/机器学习的常用概念/</id>
    <published>2017-04-08T11:28:52.000Z</published>
    <updated>2017-04-08T15:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="特征-属性"><a href="#特征-属性" class="headerlink" title="特征(属性)"></a>特征(属性)</h4><p>通常是训练样本集的列，可看作是每个列的列名，比如区分鸟的品种可以用体重，后背颜色此类的特征来加以区分</p><h4 id="特征实例"><a href="#特征实例" class="headerlink" title="特征实例"></a>特征实例</h4><p>某一特征列其中的数据</p><h4 id="特征的种类"><a href="#特征的种类" class="headerlink" title="特征的种类"></a>特征的种类</h4><ul><li>数值型</li><li>二值型(类似布尔型)</li><li>枚举类型(颜色色值)</li></ul><h4 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h4><p>训练集是用于训练机器学习算法的数据样本集合</p><h4 id="训练样本"><a href="#训练样本" class="headerlink" title="训练样本"></a>训练样本</h4><p>样本集的每一行就是一个训练样本</p><h4 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h4><p>机器学习算法的预测结果</p><p>分类:</p><ul><li>分类算法中，通常为标称型，目标变量称为<code>类别</code></li><li>回归算法中，通常为连续型</li></ul><p>训练样本集前必须要确定目标变量的值，比如根据鸟的身高，体重，颜色这些特征可以具体确定鸟的品种，品种就是目标变量，<br>而品种的值就是具体的品种名称，也就是目标变量的值</p><h4 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h4><p>指展示机器分类的结果的工作</p><p>形式包括：<code>规则集</code> <code>概率分布</code> <code>训练样本集中的实例</code> </p><h4 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h4><p>以便机器学习算法发现特征与目标变量的关系</p><p><em>机器学习的主要任务就是分类</em></p><p>将实例数据划分到合适的分类中</p><p>分类的基本流程：</p><ol><li>得到全部特征信息</li><li>算法训练(学习如何分类)</li><li>测试机器学习算法的效果</li></ol><h4 id="如何测试算法的效果？"><a href="#如何测试算法的效果？" class="headerlink" title="如何测试算法的效果？"></a>如何测试算法的效果？</h4><p>为了测试效果，通常会使用两套独立的样本集：<code>训练数据</code> 和 <code>测试数据</code></p><p><em>机器学习另外一个重要的任务：回归</em></p><p>主要用于预测数值型数据</p><h4 id="程序开始运行"><a href="#程序开始运行" class="headerlink" title="程序开始运行:"></a>程序开始运行:</h4><p>训练样本集提供目标变量 =&gt; 输入到算法 =&gt; 训练完成 =&gt; 输入测试数据(不包含目标变量) =&gt; 比较测试结果与实际目标变量的差别(回归拟合) =&gt; 得出算法的实际精确度</p><h4 id="监督学习与无监督学习"><a href="#监督学习与无监督学习" class="headerlink" title="监督学习与无监督学习"></a>监督学习与无监督学习</h4><p>监督学习指算法知道预测什么，也就是有明确的目标</p><p>回归和分类都是属于监督学习</p><p>与监督学习相比，无监督学习没有目标值</p><h3 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h3><p>作用：</p><ul><li>减少数据特征的维度</li></ul><h4 id="聚类-分析"><a href="#聚类-分析" class="headerlink" title="聚类(分析)"></a>聚类(分析)</h4><p>把相似的对象通过静态分类的方法分成不同组别或者更多的子集，相当于是把一个训练集分成了多个训练集，每个新训练集中的数据的特征相似</p><h4 id="密度估计"><a href="#密度估计" class="headerlink" title="密度估计"></a>密度估计</h4><p>指寻找描述数据统计值的过程，可以理解为要得到关于描述数据的 <code>频率分布直方图</code>，降低特征维度，使其更直观</p><h3 id="浅谈算法的选择"><a href="#浅谈算法的选择" class="headerlink" title="浅谈算法的选择"></a>浅谈算法的选择</h3><ul><li>以目的为导向：根据要完成的任务，选择监督学习的或者是非监督学习的算法</li><li>以数据来源为导向：需要分析或收集的数据是什么</li></ul><h3 id="开发机器学习应用程序的大概步骤"><a href="#开发机器学习应用程序的大概步骤" class="headerlink" title="开发机器学习应用程序的大概步骤"></a>开发机器学习应用程序的大概步骤</h3><ol><li><p>收集数据</p></li><li><p>准备输入数据</p></li><li><p>分析输入数据(人工)</p></li><li><p>训练算法(机器学习)</p></li><li><p>测试算法</p></li><li><p>使用算法</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;特征-属性&quot;&gt;&lt;a href=&quot;#特征-属性&quot; class=&quot;headerlink&quot; title=&quot;特征(属性)&quot;&gt;&lt;/a&gt;特征(属性)&lt;/h4&gt;&lt;p&gt;通常是训练样本集的列，可看作是每个列的列名，比如区分鸟的品种可以用体重，后背颜色此类的特征来加以区分&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Machine Learning" scheme="http://tecknight.xyz/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://tecknight.xyz/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Linux WEB基础 学习笔记</title>
    <link href="http://tecknight.xyz/2017/03/29/Linux-WEB%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://tecknight.xyz/2017/03/29/Linux-WEB基础-学习笔记/</id>
    <published>2017-03-29T04:39:21.000Z</published>
    <updated>2017-03-29T05:15:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统版本选择"><a href="#系统版本选择" class="headerlink" title="系统版本选择"></a>系统版本选择</h2><ul><li>根据不同发行版本的特性</li></ul><h3 id="red-hat-企业（付费）"><a href="#red-hat-企业（付费）" class="headerlink" title="red hat 企业（付费）"></a>red hat 企业（付费）</h3><h3 id="ubuntu-跨设备：服务器，台式，笔记本，嵌入式设备"><a href="#ubuntu-跨设备：服务器，台式，笔记本，嵌入式设备" class="headerlink" title="ubuntu 跨设备：服务器，台式，笔记本，嵌入式设备"></a>ubuntu 跨设备：服务器，台式，笔记本，嵌入式设备</h3><h3 id="debian-稳定可靠，但更新周期长"><a href="#debian-稳定可靠，但更新周期长" class="headerlink" title="debian 稳定可靠，但更新周期长"></a>debian 稳定可靠，但更新周期长</h3><h3 id="Mint-台式机用户并支持专利性媒体"><a href="#Mint-台式机用户并支持专利性媒体" class="headerlink" title="Mint 台式机用户并支持专利性媒体"></a>Mint 台式机用户并支持专利性媒体</h3><h3 id="Core-OS-容器化应用程序的计算机集群建设"><a href="#Core-OS-容器化应用程序的计算机集群建设" class="headerlink" title="Core OS 容器化应用程序的计算机集群建设"></a>Core OS 容器化应用程序的计算机集群建设</h3><h2 id="系统路径"><a href="#系统路径" class="headerlink" title="系统路径"></a>系统路径</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">pwd</span></code></pre><p><strong>返回当前的目录位置</strong></p><p><code>/</code>表示系统的根目录，可以进入的最高位置</p><p>所有<code>Linux</code>系统中都可以找到<code>/home</code>这样的目录，除少数例外情况，<code>home</code>目录可以容纳每个用户的所有主目录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -a</code></pre><p><strong>显示所有文件包括隐藏文件</strong></p><p>任何前缀是<code>.</code>的文件都是会被系统隐藏的</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -al</code></pre><p>以长格式打印所有文件信息</p><img src="/2017/03/29/Linux-WEB基础-学习笔记/2.png" alt="2.png" title=""><pre class=" language-bash"><code class="language-bash">drwxr-xr-x 4 root root 4096 Jul 2 21:00 <span class="token punctuation">..</span></code></pre><p>首字符为d，代表这个结果是目录，<code>-</code>代表文件</p><p>后面的每三个分割开来看，分别对应所有者<code>owner</code>，组<code>group</code>，所有人<code>everyone</code></p><p>分别是读，写和是否为可执行文件对应字母为<code>r</code>,<code>w</code>,<code>x</code></p><p>后面紧接着就是所有者和组，linux在创建用户的时候会自动创建相同名字的组</p><h2 id="根目录常用文件夹"><a href="#根目录常用文件夹" class="headerlink" title="根目录常用文件夹"></a>根目录常用文件夹</h2><p><code>etc</code> 存储配置文件，配置服务器的时候就会修改其中的文件</p><p><code>var</code> 存储可变的文件，里面的文件一般会随着时间的推移而变大，可找到系统日志和应用程序日志</p><p><code>bin</code> 用于存储可执行的二进制文件，所有用户都可以访问，一般在启动时和系统维护进程中用到</p><p><code>sbin</code> 与<code>bin</code>类似除了其中的可执行文件只能被<code>root</code>用户用于系统管理和维护</p><p><code>lib</code> 存储支持系统中存储的二进制文件的库文件</p><p><code>usr</code> 用于存储用户程序</p><h2 id="命令的运行过程"><a href="#命令的运行过程" class="headerlink" title="命令的运行过程"></a>命令的运行过程</h2><ol><li>输入<code>ls</code></li><li>系统在<code>$path</code>中按顺序寻找路径下名称为<code>ls</code>的可执行文件</li><li>找到在<code>bin</code>中</li></ol><h2 id="Linux-安全"><a href="#Linux-安全" class="headerlink" title="Linux 安全"></a>Linux 安全</h2><h3 id="使用最少权限"><a href="#使用最少权限" class="headerlink" title="使用最少权限"></a>使用最少权限</h3><p><strong>超级用户root</strong></p><p>通常情况下，我们禁用root的可远程访问权限，用自己创建的身份登录，然后通过其他命令，我们也可以以root身份运行超级用户的命令，使服务器在用户名及密码未知的情况下被攻破的可能性得到降低</p><p>普通用户可以在命令前面加上<code>sudo</code>来以<code>root</code>的身份运行命令，其中的好处是会出现警告，提前预知危险</p><h3 id="使用包管理软件"><a href="#使用包管理软件" class="headerlink" title="使用包管理软件"></a>使用包管理软件</h3><p>所有可用的程序包来源都会列在<code>/etc/apt/sources.list</code>文件中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update</code></pre><p>更新仓库源，并不会对系统进行更改</p><p>真正升级包要使用</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade</code></pre><h4 id="包finger的使用"><a href="#包finger的使用" class="headerlink" title="包finger的使用"></a>包finger的使用</h4><p>用途：用于查询用户的各种信息打印成易于阅读的格式</p><p>Command</p><pre class=" language-bash"><code class="language-bash">fingerfinger 用户名</code></pre><p>用户信息大部分都存储在<code>/etc/passwd</code>中，用<code>cat</code>打开如下</p><img src="/2017/03/29/Linux-WEB基础-学习笔记/1.png" alt="1.png" title=""><p>文件中的每一行代表一个单独的用户，每个条目包含数个由冒号隔开的字段</p><p>第一个字段是指用户名，第二个用于存储加密的密码，第三和第四字段分别存储用户的ID和组ID，第五个字段用于存储更多说明，最后两个是用户的主目录和用户默认的<code>shell</code>，可以看到，linux的<code>root</code>用户的组ID和用户ID都是0</p><h3 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h3><ul><li>创建新用户</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> adduser student</code></pre><ul><li>远程SSH登录</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> student@127.0.0.1 -p 2222</code></pre><p><code>用户名@IP地址</code></p><p><code>-p 端口号</code></p><ul><li>赋予<code>sudo</code>权限</li></ul><p>有sudo权限的用户登录执行</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> /etc/sudoers</code></pre><p>ubuntu中有<code>sudo</code>权限的用户都在<code>/etc/sudoers.d</code>中</p><p>可使用已有的用户进行<code>cp</code>成用户名，然后用<code>nano</code>进行编辑</p><p>将名字改为用户名保存</p><ul><li>强制下次登录时重置密码</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">passwd</span> -e 用户名</code></pre><h3 id="基于密钥的身份验证"><a href="#基于密钥的身份验证" class="headerlink" title="基于密钥的身份验证"></a>基于密钥的身份验证</h3><h4 id="公共密钥加密"><a href="#公共密钥加密" class="headerlink" title="公共密钥加密"></a>公共密钥加密</h4><p>服务器发送任意消息至客户端，客户端用私有密钥进行加密，再将加密后的消息发送给服务器，服务器用公共密钥进行解密，如果与服务器发送的值相等，那么通过</p><p><strong>私有密钥要自己保留</strong></p><h4 id="在本地生成密钥对"><a href="#在本地生成密钥对" class="headerlink" title="在本地生成密钥对"></a>在本地生成密钥对</h4><pre class=" language-bash"><code class="language-bash">ssh-keygen</code></pre><p>为密钥添加密码</p><p>生成的<code>.pub</code>文件就是放在服务器上用于密码身份验证的文件</p><h4 id="将公钥放在服务器上"><a href="#将公钥放在服务器上" class="headerlink" title="将公钥放在服务器上"></a>将公钥放在服务器上</h4><p>登录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> .ssh<span class="token function">touch</span> .ssh/authorized_keys</code></pre><p>拷贝本地的密钥内容至服务器更创建的文件中，并为文件设置权限</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> 700 .ssh<span class="token function">chmod</span> 644 .ssh/authorized_keys</code></pre><p>使用ssh密钥登录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> student@127.0.0.1 -p 2222 -i ~/.ssh/密钥名称</code></pre><h4 id="禁用密码登录"><a href="#禁用密码登录" class="headerlink" title="禁用密码登录"></a>禁用密码登录</h4><ul><li>编辑<code>SSHD</code>配置文件</li></ul><p>SSHD: 运行于服务器上监听SSH连接的服务</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">nano</span> /etc/ssh/sshd_config</code></pre><p>将<code>PasswordAuthentication</code>设置为<code>no</code>保存</p><p>然后重启服务，让它重新读取配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">ssh</span> restart</code></pre><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><img src="/2017/03/29/Linux-WEB基础-学习笔记/3.png" alt="3.png" title=""><h4 id="数字与权限的关系"><a href="#数字与权限的关系" class="headerlink" title="数字与权限的关系"></a>数字与权限的关系</h4><p>r = 4</p><p>w = 2</p><p>x = 1</p><p>无需权限，值为0</p><p>加在一起即为要进行应用的全部权限数量（注意只是对于一种用户）</p><p><strong>系统需要一次处理三个权限，以一次设置用户，组和所有人的权限</strong></p><h4 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h4><pre><code>chmod 数字 文件夹或文件 //改权限chown 所有者 文件 //更改所有者chgrp 组名 文件名 //更改组</code></pre><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>每个应用程序都会被分配端口来处理各自的请求</p><p>常见端口如下图</p><img src="/2017/03/29/Linux-WEB基础-学习笔记/4.png" alt="4.png" title=""><p>通过防火墙，可以控制服务器允许哪个端口接受请求</p><h4 id="只开放让应用程序行使正常功能的端口"><a href="#只开放让应用程序行使正常功能的端口" class="headerlink" title="只开放让应用程序行使正常功能的端口"></a>只开放让应用程序行使正常功能的端口</h4><h4 id="ubuntu-ufw-防火墙"><a href="#ubuntu-ufw-防火墙" class="headerlink" title="ubuntu ufw 防火墙"></a>ubuntu ufw 防火墙</h4><p>激活<code>ufw</code></p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> ufw status //查看状态</code></pre><p><strong>写入防火墙规则并开启防火墙</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> ufw default deny incoming  //阻止所有 default allow outgoing 允许所有<span class="token function">sudo</span> ufw allow <span class="token function">ssh</span>    //允许开放SSH连接端口<span class="token function">sudo</span> ufw allow www     //允许HTTP请求<span class="token function">sudo</span> ufw <span class="token function">enable</span>        //开启防火墙</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统版本选择&quot;&gt;&lt;a href=&quot;#系统版本选择&quot; class=&quot;headerlink&quot; title=&quot;系统版本选择&quot;&gt;&lt;/a&gt;系统版本选择&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据不同发行版本的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;red-hat-企业（付费）&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="web" scheme="http://tecknight.xyz/tags/web/"/>
    
      <category term="shell" scheme="http://tecknight.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Express下多次callback引发的问题</title>
    <link href="http://tecknight.xyz/2017/03/23/Express%E4%B8%8B%E5%A4%9A%E6%AC%A1callback%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://tecknight.xyz/2017/03/23/Express下多次callback引发的问题/</id>
    <published>2017-03-23T15:26:43.000Z</published>
    <updated>2017-03-25T03:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误结果"><a href="#错误结果" class="headerlink" title="错误结果"></a>错误结果</h3><blockquote><p>Error: Can’t render headers after they are sent to the client.</p><p>错误：当响应头被发回客户端时不能被正确渲染！</p></blockquote><h3 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h3><blockquote><p>Express环境下使用mongoose model 进行模糊查询时，需要用ORM进行至少一次至多两次的查询，查询用的都是Promise进行的异步操作</p></blockquote><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ul><li><p><strong>响应头的设置出现了冲突</strong>  </p></li><li><p>是<code>res.send(docs)</code>出错</p></li><li><p><strong>调试时移除了其中一个<code>Promise</code>查询，错误消失</strong></p></li><li><p>问题出在<code>Promise</code>上</p></li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>为什么连续的两个<code>Promise</code>回调会最终导致响应头渲染冲突?</strong></p><p>渲染冲突出现在错误的顶部，跟错误抛出的顺序有关，这与<code>Express</code>自带的<code>res</code>对象有关，而<code>res</code>又继承自<code>node.js</code>原生的<code>http.ServerResponse</code> 类，在<code>res</code>调用<code>res.writeHead(statusCode)</code>写入响应头的状态码之前，我们可以尽情的写入响应头的头信息，在一个<code>res.send(docs)</code>中，应该包含着以下几步，有的是<code>exprerss</code>自己的，有的则是属于<code>node</code>原生<code>http</code>模块的</p><p><strong>按以下顺序开始运行:</strong></p><blockquote><p>res.writeContinue()</p><p>res.statusCode = 404</p><p>res.setHeader(name, value)</p><p>res.getHeader(name)</p><p>res.removeHeader(name)</p><p>res.header(key[, val]) (Express only)</p><p>res.charset = ‘utf-8’ (Express only)</p><p>res.contentType(type) (Express only)</p><p>res.send([body]) (Express only)</p></blockquote><p>最后我们的查询数据是以响应内容中的<code>body</code>的形式返回给客户端的，当要进行<code>send</code>的时候，<code>node</code>自带的函数就会先运行，当然运行第一个<code>Promise</code>的时候是没有问题的，问题在于:<strong><code>send</code>本身并不能中断当前执行的任务</strong>，只要还没有<code>return</code>，代码仍然会继续运行，这也恰恰印证了<code>node</code>的异步非阻塞IO的特性，即便是第一个<code>Promise</code>执行时，并不会阻塞第二个<code>Promise</code>的继续执行，如果第一个<code>Promise</code>的<code>res.send</code>已经执行，当第二个<code>Promise</code>被执行时，执行至第三步，也就是设置响应头的时候原先的响应头信息依然存在，触犯了<strong><code>node</code></strong>中不能重复设置响应头信息的规定，所以<code>node</code>先抛错，这一切看起来也就顺其自然了</p><h3 id="All-in-all-解决方案呢？"><a href="#All-in-all-解决方案呢？" class="headerlink" title="All in all 解决方案呢？"></a>All in all 解决方案呢？</h3><ul><li>避免使用多次<code>send</code>,多次设置响应头就会出现此错误</li><li>谨慎使用异步<code>Promise</code>，可以考虑<code>Promise</code>嵌套<strong>（推荐）</strong></li><li><code>send</code>之前记得加上<code>return</code>让后面的代码不会运行，但这个方法不好难以控制，当异步操作写在一起的时候，谁知道会是哪一个家伙先结束呢？ </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;错误结果&quot;&gt;&lt;a href=&quot;#错误结果&quot; class=&quot;headerlink&quot; title=&quot;错误结果&quot;&gt;&lt;/a&gt;错误结果&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Error: Can’t render headers after they are sent t
      
    
    </summary>
    
      <category term="Node" scheme="http://tecknight.xyz/categories/Node/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="Express" scheme="http://tecknight.xyz/tags/Express/"/>
    
      <category term="问题总结" scheme="http://tecknight.xyz/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="异步" scheme="http://tecknight.xyz/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Debug" scheme="http://tecknight.xyz/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 升级最新版本git</title>
    <link href="http://tecknight.xyz/2017/03/11/CentOS-7-%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%ACgit/"/>
    <id>http://tecknight.xyz/2017/03/11/CentOS-7-升级最新版本git/</id>
    <published>2017-03-11T02:30:11.000Z</published>
    <updated>2017-03-29T04:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a>准备工作:</h3><blockquote><p>CentOS 上的最新git版本也只有1.8.3，就想试着装上最新的版本，没想到差点玩脱，全当记录一次冒险经历</p></blockquote><ul><li>Development tools 没装的要装上，不然GCC编译时会出错</li></ul><pre><code># yum -y groupinstall Development tools</code></pre><ul><li>再卸载CentOS自带的老版本git </li></ul><pre><code># yum -y remove git</code></pre><h3 id="下载git并安装"><a href="#下载git并安装" class="headerlink" title="下载git并安装"></a>下载git并安装</h3><pre><code># cd /usr/src# wget https://www.kernel.org/pub/software/scm/git/git-2.12.0.tar.gz# tar xzf git-2.12.0.tar.gz</code></pre><h4 id="安装注意事项："><a href="#安装注意事项：" class="headerlink" title="安装注意事项："></a>安装注意事项：</h4><pre><code># cd git-2.12.0# make prefix=/usr/local/git all</code></pre><p>此时报错</p><pre class=" language-bash"><code class="language-bash">/usr/src/git-2.12.0/utf8.c:463：对‘libiconv’未定义的引用libgit.a<span class="token punctuation">(</span>utf8.o<span class="token punctuation">)</span>：在函数‘reencode_string_len’中：/usr/src/git-2.12.0/utf8.c:524：对‘libiconv_open’未定义的引用/usr/src/git-2.12.0/utf8.c:535：对‘libiconv_close’未定义的引用/usr/src/git-2.12.0/utf8.c:529：对‘libiconv_open’未定义的引用collect2: 错误：ld 返回 1make: *** <span class="token punctuation">[</span>git-credential-store<span class="token punctuation">]</span> 错误 1</code></pre><p>原方案：</p><pre><code># make prefix=/usr/local/git all# make prefix=/usr/local/git install</code></pre><p>解决方案：</p><p>可替换为</p><pre><code># ./configure --without-iconv# make CFLAGS=-liconv prefix=/usr/local/git all# make CFLAGS=-liconv prefix=/usr/local/git install</code></pre><h3 id="最后将git加入环境变量"><a href="#最后将git加入环境变量" class="headerlink" title="最后将git加入环境变量"></a>最后将git加入环境变量</h3><pre><code># echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc# source /etc/bashrc</code></pre><p><strong>大功告成！查看一下git的版本</strong></p><pre><code># git --version&gt;&gt; git version 2.12.0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作:&quot;&gt;&lt;/a&gt;准备工作:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;CentOS 上的最新git版本也只有1.8.3，就想试着装上最新的版本，没想到差点玩脱，全当
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="centOS" scheme="http://tecknight.xyz/tags/centOS/"/>
    
      <category term="git" scheme="http://tecknight.xyz/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>vue-router 快速入门</title>
    <link href="http://tecknight.xyz/2017/03/01/vue-router-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://tecknight.xyz/2017/03/01/vue-router-快速入门/</id>
    <published>2017-03-01T10:00:37.000Z</published>
    <updated>2017-03-22T12:30:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> vue-router --save</code></pre><a id="more"></a><p>routes.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'./pages/Home.vue'</span><span class="token keyword">import</span> Gifs <span class="token keyword">from</span> <span class="token string">'./pages/Gifs.vue'</span><span class="token keyword">import</span> User <span class="token keyword">from</span> <span class="token string">'./pages/User.vue'</span><span class="token keyword">export</span> <span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> Home <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/gifs'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> Gifs <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//指定路由和对应要渲染的组件</span>    <span class="token comment" spellcheck="true">//404的path应该是'*',要放在最末尾，当前面的都匹配不到时才匹配到404页面</span>    <span class="token comment" spellcheck="true">//this.$route.params.id 可以从路由中拿到id数据</span><span class="token punctuation">]</span></code></pre><p>main.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> routes <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./routes'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//路由初始化</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将路由注入根组件</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token operator">...</span>  router<span class="token punctuation">,</span>  render<span class="token punctuation">:</span> h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>App.vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre><p>在模板中标注出组件渲染的位置</p><h3 id="号的含义"><a href="#号的含义" class="headerlink" title="#号的含义"></a>#号的含义</h3><p>#号前表示的是发送给服务端的请求，要求返回html文件，而#号后表示的是发送给本地js的请求以寻求解决</p><h3 id="路由参数动态绑定"><a href="#路由参数动态绑定" class="headerlink" title="路由参数动态绑定"></a>路由参数动态绑定</h3><p>使用watch</p><pre class=" language-javascript"><code class="language-javascript">watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">'$route'</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span><span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//to当前路由，from上一个路由</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> to<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="路由的数据传递"><a href="#路由的数据传递" class="headerlink" title="路由的数据传递"></a>路由的数据传递</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ name: <span class="token punctuation">'</span>userEdit<span class="token punctuation">'</span>, params: { id: $route.params.id }, query: { locale: <span class="token punctuation">'</span>en<span class="token punctuation">'</span>, list: 2 } }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span></code></pre><p>传<code>query</code>参数可以达到地址栏出现<code>/?locale=en&amp;list=2</code><br>通过 <code>$route.query.键名</code> 来访问</p><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p><code>router-view</code> 可以通过配置名字 <code>name</code> 来指定组件渲染的位置，增加了组件的复用性，比如分成 <code>header</code> <code>main</code> <code>hero</code> <code>footer</code> 来分别在一个视图中的不同位置上加载不同的组件 </p><h3 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h3><p>我们只需要加载我们需要的组件呈现给用户，而其他不需要第一时间加载的组件，可以使用 <code>webpack</code> 实现异步加载，只在需要的时候才会发出请求，请求加载另一个组件</p><p>routes.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> User <span class="token operator">=</span> resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./components/user/User.vue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./components/user/User.vue'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'GroupName'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//webpack 异步加载，通过组名，将要同时一起加载的组件打包加载</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置路由&quot;&gt;&lt;a href=&quot;#配置路由&quot; class=&quot;headerlink&quot; title=&quot;配置路由&quot;&gt;&lt;/a&gt;配置路由&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ npm install vue-router --save
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://tecknight.xyz/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://tecknight.xyz/tags/Vue/"/>
    
      <category term="router" scheme="http://tecknight.xyz/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>vuex快速入门</title>
    <link href="http://tecknight.xyz/2017/02/08/vuex%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://tecknight.xyz/2017/02/08/vuex快速入门/</id>
    <published>2017-02-08T00:26:19.000Z</published>
    <updated>2017-03-22T12:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本用途："><a href="#基本用途：" class="headerlink" title="基本用途："></a>基本用途：</h3><ul><li><p>将某些data变成组件间公用的状态，组件随时都可以进行访问和响应，解决了<code>props</code>传值的链式响应的代码冗余</p></li><li><p>给状态配以公用方法，将状态的变更及时响应并处理</p></li></ul><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><a id="more"></a><p>/store/store.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    state<span class="token punctuation">:</span> <span class="token punctuation">{</span>        sideBarOpened<span class="token punctuation">:</span> <span class="token boolean">false</span>        <span class="token comment" spellcheck="true">//放置公用状态</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>        changeState<span class="token punctuation">:</span> state <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//相当于vue实例中的methods,用于处理公用data</span>            <span class="token comment" spellcheck="true">//自vuex 面向组件的数据处理</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//写法与getters相类似</span>        <span class="token comment" spellcheck="true">//组件想要对于vuex 中的数据进行的处理</span>        <span class="token comment" spellcheck="true">//组件中采用this.$store.commit('方法名') 的方式调用，实现充分解耦</span>        <span class="token comment" spellcheck="true">//内部操作必须在此刻完成(同步)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使得mutations能够实现异步调用，实现例如延迟调用</span>        increment <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'突变方法名'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//payload应该是一个对象，可通过模板方法调用传入对象的方式将数据从组件传入vuex</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token function">asyncIncrement</span><span class="token punctuation">(</span><span class="token punctuation">{</span>commit<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                  <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>              <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//引入某一个state的以上集合的模块，会自动分别填充到上面，使得结构更加清晰</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>main.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> store <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./store/store'</span><span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  store<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//注入根组件</span>  <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="访问vuex中的数据和方法"><a href="#访问vuex中的数据和方法" class="headerlink" title="访问vuex中的数据和方法"></a>访问vuex中的数据和方法</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>数据名<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>方法名</code></pre><p>受影响组件局部定义计算属性响应变化数据</p><pre class=" language-javascript"><code class="language-javascript">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>     open <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>sideBarOpened     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>将 store 中的 getters/mutations 映射到局部(计算属性/方法)使用<code>mapGetters/mapMutations</code>辅助函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 使用对象展开运算符将 getters 混入 computed 对象中</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">//映射 this.doneTodosCount 为 store.getters.doneTodosCount</span>      <span class="token string">'doneTodosCount'</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">//'getter名称',</span>      <span class="token comment" spellcheck="true">// 映射 this.doneCount 为 store.getters.doneTodosCount</span>          doneCount<span class="token punctuation">:</span> <span class="token string">'doneTodosCount'</span>      <span class="token comment" spellcheck="true">// 三个点表示将内部拿出生成键值对，这样使得组件本身的计算属性不受影响</span>      <span class="token comment" spellcheck="true">// 此语法依赖babel-preset-stage-2</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span></code></pre><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>mutation 必须是同步函数 — devtool要保存快照，方便追踪状态变化</p><p>使用 v-model 绑定 vuex 计算属性的时候要设置get 和 set 才能双向绑定</p><pre class=" language-javascript"><code class="language-javascript">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    value<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token keyword">set</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'updateValue'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本用途：&quot;&gt;&lt;a href=&quot;#基本用途：&quot; class=&quot;headerlink&quot; title=&quot;基本用途：&quot;&gt;&lt;/a&gt;基本用途：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将某些data变成组件间公用的状态，组件随时都可以进行访问和响应，解决了&lt;code&gt;props&lt;/code&gt;传值的链式响应的代码冗余&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给状态配以公用方法，将状态的变更及时响应并处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本用法：&quot;&gt;&lt;a href=&quot;#基本用法：&quot; class=&quot;headerlink&quot; title=&quot;基本用法：&quot;&gt;&lt;/a&gt;基本用法：&lt;/h3&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://tecknight.xyz/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://tecknight.xyz/tags/Vue/"/>
    
      <category term="Vuex" scheme="http://tecknight.xyz/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Laravel学习笔记</title>
    <link href="http://tecknight.xyz/2017/02/03/Laravel%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://tecknight.xyz/2017/02/03/Laravel 学习笔记/</id>
    <published>2017-02-03T05:26:19.000Z</published>
    <updated>2017-03-22T14:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ul><li>compact(‘变量1’,’变量2’)    </li></ul><p>类似于es6 的简写，会生成类似于<code>[&#39;name&#39; =&gt; $name]</code>的键值对</p><ul><li>dd(变量)</li></ul><p>程序运行到此处终止并输出变量的值</p><ul><li>Tinker 助手</li></ul><pre class=" language-bash"><code class="language-bash">php artisan tinker</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> App\Model::pluck<span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//只取出此字段<span class="token operator">>></span><span class="token operator">></span> App\Model::where<span class="token punctuation">(</span><span class="token string">'id'</span>, <span class="token string">'>='</span>, 2<span class="token punctuation">)</span>-<span class="token operator">></span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span> App\Model::all<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span> App\Model::first<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>request()-&gt;all()</code></li><li><code>request([&#39;title&#39;, &#39;body&#39;])</code></li></ul><p>获取所有的post数据</p><p>只获取title和body</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>删除文件<br>删除完<code>migration</code>文件之后都要清除Composer中自动加载的记录，刷新自动加载记录</li></ul><pre class=" language-bash"><code class="language-bash">$ composer dump-autoload</code></pre><h3 id="技巧提点"><a href="#技巧提点" class="headerlink" title="技巧提点"></a>技巧提点</h3><ul><li>进一步封装查询语句</li></ul><p>Model.php</p><pre class=" language-php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">scopeIncompleted</span><span class="token punctuation">(</span><span class="token variable">$query</span><span class="token punctuation">,</span> <span class="token variable">$val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token variable">$query</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">'completed'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将查询语句进行封装，调用时相当于静态方法</span>    <span class="token comment" spellcheck="true">//Model::incompleted();</span><span class="token punctuation">}</span></code></pre><ul><li>Model与路由的绑定</li></ul><pre class=" language-php"><code class="language-php">    Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/tasks/{thetask}'</span><span class="token punctuation">,</span> <span class="token string">'TasksController@show'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span>Task <span class="token variable">$thetask</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">view</span><span class="token punctuation">(</span><span class="token string">'tasks.show'</span><span class="token punctuation">,</span> <span class="token function">compact</span><span class="token punctuation">(</span><span class="token string">'thetask'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//路由中括号内的参数名必须与Controller中的接收参数的变量名字一致，类型是Model对象</span></code></pre><ul><li>命名规则</li></ul><p>controller =&gt; PostsController<br>Model =&gt; Post<br>migration =&gt; create_posts_table</p><ul><li>RESTFul</li></ul><pre class=" language-bash"><code class="language-bash">$ php artisan make:Controller TasksController -r</code></pre><p>创建一个resourceful controller</p><ul><li>文件路径更改</li></ul><p>与其相关的命名空间，包括文件本身的命名空间都需要进行修改！</p><ul><li>快速查看所有的路由</li></ul><pre class=" language-bash"><code class="language-bash">$ php artisan route:list</code></pre><ul><li>重定向返回至上一次请求尝试访问的页面</li></ul><pre class=" language-php"><code class="language-php"><span class="token keyword">return</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">intended</span><span class="token punctuation">(</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token string">'users.show'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Auth<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="关于Blade"><a href="#关于Blade" class="headerlink" title="关于Blade"></a>关于Blade</h3><p><code>@yield(&#39;title&#39;, &#39;Sample&#39;)</code></p><p>声明title变量及其默认值</p><pre><code>@yield(&#39;content&#39;)// content区域@extends(&#39;layouts.default&#39;)@section(&#39;content&#39;)// 内容将会被插入布局模板中@stop</code></pre><p><code>@yield</code> 用于定义</p><p><code>@section</code> 用于插入值</p><p><code>@include(&#39;shared.user_info&#39;, [&#39;user&#39; =&gt; $user])</code></p><p>给局部视图传参数</p><p><code>old(&#39;name名称&#39;)</code></p><p>辅助函数显示旧的输入数据</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul><li>每一个Model内部都有三个属性</li></ul><p><code>$table</code> <code>$fillable</code> <code>$hidden</code></p><p>指明交互的数据表名称，能进行更新的字段，JSON形式显示时隐藏的字段</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>每一个controller中都有一个<code>validator</code>，可以用来验证字段</li></ul><h3 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h3><ol><li>创建会话实例</li></ol><p><code>session()-&gt;flash(&#39;success&#39;, &#39;欢迎，您将在这里开启一段新的旅程~&#39;);</code></p><p>flash方法使得会话缓存只在下一次请求中有效，第一个参数是键名，第二个参数是键值</p><ol><li>访问会话实例</li></ol><p><code>session()-&gt;get(&#39;success&#39;)</code></p><h3 id="Auth-认证系统"><a href="#Auth-认证系统" class="headerlink" title="Auth 认证系统"></a>Auth 认证系统</h3><p><code>Auth::attempt()</code>尝试登陆</p><p><code>Auth::user()</code>当前登录实例</p><p><code>Auth::check()</code> 是否已经登录</p><p>API:</p><p><code>bool attempt(array $credentials = array(), bool $remember = false)</code></p><p>第二个参数用来开发记住密码</p><h3 id="中间件的使用"><a href="#中间件的使用" class="headerlink" title="中间件的使用"></a>中间件的使用</h3><ul><li>在用户控制器构造方法中应用中间件</li></ul><pre class=" language-php"><code class="language-php">    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">middleware</span><span class="token punctuation">(</span><span class="token string">'auth'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>                        <span class="token string">'only'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">'edit'</span><span class="token punctuation">,</span> <span class="token string">'update'</span><span class="token punctuation">]</span>        <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li><code>Authenticate.php</code>中进行重定向</li></ul><pre class=" language-php"><code class="language-php">    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token variable">$request</span><span class="token punctuation">,</span> Closure <span class="token variable">$next</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">auth</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">guest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">response</span><span class="token punctuation">(</span><span class="token string">'Unauthorized.'</span><span class="token punctuation">,</span> <span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">guest</span><span class="token punctuation">(</span><span class="token string">'login'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token variable">$next</span><span class="token punctuation">(</span><span class="token variable">$request</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="授权策略"><a href="#授权策略" class="headerlink" title="授权策略"></a>授权策略</h3><p>已登录的用户之间的权限控制</p><ul><li>创建Policy文件并创建用户比对方法</li></ul><pre class=" language-php"><code class="language-php">    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span>User <span class="token variable">$currentUser</span><span class="token punctuation">,</span> User <span class="token variable">$user</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$currentUser</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span> <span class="token operator">===</span> <span class="token variable">$user</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>在<code>AuthServiceProvider</code>中进行授权策略的配置，将用户模型指定授权策略</li></ul><pre class=" language-php"><code class="language-php">    <span class="token keyword">protected</span> <span class="token variable">$policies</span> <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string">'App\Model'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'App\Policies\ModelPolicy'</span><span class="token punctuation">,</span>        User<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span> <span class="token operator">=</span><span class="token operator">></span> UserPolicy<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span>        <span class="token comment" spellcheck="true">//全路径匹配</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><ul><li>将查询时返回的User实例发送给授权策略进行比较</li></ul><pre class=" language-php"><code class="language-php">   <span class="token variable">$user</span> <span class="token operator">=</span> User<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">findOrFail</span><span class="token punctuation">(</span><span class="token variable">$id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">authorize</span><span class="token punctuation">(</span><span class="token string">'update'</span><span class="token punctuation">,</span> <span class="token variable">$user</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常用函数：&quot;&gt;&lt;a href=&quot;#常用函数：&quot; class=&quot;headerlink&quot; title=&quot;常用函数：&quot;&gt;&lt;/a&gt;常用函数：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;compact(‘变量1’,’变量2’)    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似于es6 的简写，会生
      
    
    </summary>
    
      <category term="PHP" scheme="http://tecknight.xyz/categories/PHP/"/>
    
    
      <category term="php" scheme="http://tecknight.xyz/tags/php/"/>
    
      <category term="Laravel" scheme="http://tecknight.xyz/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 5 常用帮助函数</title>
    <link href="http://tecknight.xyz/2017/02/03/Laravel%205%20%E5%B8%B8%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%87%BD%E6%95%B0/"/>
    <id>http://tecknight.xyz/2017/02/03/Laravel 5 常用帮助函数/</id>
    <published>2017-02-03T05:26:19.000Z</published>
    <updated>2017-03-22T14:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-app-用于快速生成对应命名空间下的类的实例"><a href="#1-app-用于快速生成对应命名空间下的类的实例" class="headerlink" title="1.app() 用于快速生成对应命名空间下的类的实例"></a>1.app() 用于快速生成对应命名空间下的类的实例</h3><pre class=" language-php"><code class="language-php"><span class="token variable">$faker</span> <span class="token operator">=</span> <span class="token function">app</span><span class="token punctuation">(</span>Faker\<span class="token package">Generator</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//生成了一个Faker的生成器实例</span></code></pre><h3 id="2-str-random-用于快速生成限定范围内的随机字符串"><a href="#2-str-random-用于快速生成限定范围内的随机字符串" class="headerlink" title="2.str_random() 用于快速生成限定范围内的随机字符串"></a>2.str_random() 用于快速生成限定范围内的随机字符串</h3><pre class=" language-php"><code class="language-php"><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token function">str_random</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//生成10位随机密码</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-app-用于快速生成对应命名空间下的类的实例&quot;&gt;&lt;a href=&quot;#1-app-用于快速生成对应命名空间下的类的实例&quot; class=&quot;headerlink&quot; title=&quot;1.app() 用于快速生成对应命名空间下的类的实例&quot;&gt;&lt;/a&gt;1.app() 用于快速
      
    
    </summary>
    
      <category term="php" scheme="http://tecknight.xyz/categories/php/"/>
    
    
      <category term="php" scheme="http://tecknight.xyz/tags/php/"/>
    
      <category term="Laravel" scheme="http://tecknight.xyz/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel5 新手填坑指南</title>
    <link href="http://tecknight.xyz/2017/02/03/Laravel%20%E6%96%B0%E6%89%8B%E5%A1%AB%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://tecknight.xyz/2017/02/03/Laravel 新手填坑指南/</id>
    <published>2017-02-03T05:26:19.000Z</published>
    <updated>2017-03-22T14:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器篇"><a href="#浏览器篇" class="headerlink" title="浏览器篇"></a>浏览器篇</h3><p>开发浏览器: Chorme（不用解释）</p><p>注意事项：</p><p>一定要先清缓存！清缓存！清缓存！ 重要的说三遍。</p><h3 id="环境配置篇"><a href="#环境配置篇" class="headerlink" title="环境配置篇"></a>环境配置篇</h3><p>开发环境：</p><p>Mac/Linux (少很多麻烦)</p><p>首选: Laravel Homestead (Mac上配置很轻松)</p><h3 id="正确开发习惯养成"><a href="#正确开发习惯养成" class="headerlink" title="正确开发习惯养成"></a>正确开发习惯养成</h3><p>千万注意每一个<code>function</code>的内容编写的时候先把<code>return</code>带上，返回的一般为数据或视图亦或是附上数据的视图，就算返回视图也要返回一个提示的局部视图闪现</p><h3 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h3><ol><li><p>涉及数据库的命令除了<code>artisan</code>新建<code>Model</code>文件以外最好都在虚拟机中执行，包括用<code>php artisan migrate</code></p></li><li><p><code>Model</code>中的代码改变之后，最好<code>migrate:refresh</code>一下，虽然还不理解Eloquent背后的机制，但是可以肯定的是，这样一种映射结构是牢固紧密的，如果Model中的函数被调用一次，那么,这种调用的映射关系会与数据库有持久性关联，如果<code>Model</code>的函数写错了，并且此函数被调用过了，请麻烦<code>refresh</code>一下</p></li><li><p>Eloquent 修改器在写的时候一定谨慎编写，尤其是用<code>bcrypt</code>加密密码存入数据库的时候</p></li></ol><h5 id="注意：如果不是修改原来的migration而是新建migration的话直接php-artisan-migrate即可"><a href="#注意：如果不是修改原来的migration而是新建migration的话直接php-artisan-migrate即可" class="headerlink" title="注意：如果不是修改原来的migration而是新建migration的话直接php artisan migrate即可"></a>注意：如果不是修改原来的migration而是新建migration的话直接<code>php artisan migrate</code>即可</h5><h3 id="目录结构篇"><a href="#目录结构篇" class="headerlink" title="目录结构篇"></a>目录结构篇</h3><ol><li>目录结构一旦更改，本身以及引用此类的命名空间也必须进行<code>全局替换</code>！！</li></ol><h3 id="命名空间篇"><a href="#命名空间篇" class="headerlink" title="命名空间篇"></a>命名空间篇</h3><ol><li>很多的<code>Class couldn&#39;t find</code>这类的错误都是没有写<code>use</code>进行引用就直接用了</li></ol><h3 id="路由篇"><a href="#路由篇" class="headerlink" title="路由篇"></a>路由篇</h3><ol><li>决定统一用REST过后最好用<code>resource</code>一次搞定</li></ol><h3 id="用户登录篇-Auth"><a href="#用户登录篇-Auth" class="headerlink" title="用户登录篇 Auth"></a>用户登录篇 Auth</h3><ol><li><p>引用的时候必须写成 </p><pre class=" language-php"><code class="language-php"> <span class="token keyword">use</span> <span class="token package">Auth</span><span class="token punctuation">;</span></code></pre></li><li><p>所有路由都要加上<code>-&gt;name(&#39;_name_&#39;)</code>，不然<code>&amp;#123;&amp;#123; route(&#39;name) &amp;#125;&amp;#125;</code>用不了</p></li></ol><h3 id="表单篇-RESTful"><a href="#表单篇-RESTful" class="headerlink" title="表单篇 RESTful"></a>表单篇 RESTful</h3><ol><li>用户的退出登录可以看成是提交一个DELETE表单</li><li>表单要加上<code>{&amp;#123;&amp;#123; csrf_field() &amp;#125;&amp;#125;</code>生成令牌token</li><li>需要伪装的协议必须加上<code>&amp;#123;&amp;#123; method_field(&#39;PATCH&#39;) &amp;#125;&amp;#125;</code>或<code>&amp;#123;&amp;#123; method_field(&#39;DELETE&#39;) &amp;#125;&amp;#125;</code></li></ol><h3 id="数据绑定视图"><a href="#数据绑定视图" class="headerlink" title="数据绑定视图"></a>数据绑定视图</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">return</span> <span class="token function">view</span><span class="token punctuation">(</span><span class="token string">'users.edit'</span><span class="token punctuation">,</span> <span class="token function">compact</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用compact将user实例数据与视图进行绑定</span></code></pre><h4 id="注意compact的参数是字符串！！！"><a href="#注意compact的参数是字符串！！！" class="headerlink" title="注意compact的参数是字符串！！！"></a>注意compact的参数是字符串！！！</h4><p>用户数据与视图进行绑定后，便可以在视图上通过 <code>$user</code> 来访问用户对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器篇&quot;&gt;&lt;a href=&quot;#浏览器篇&quot; class=&quot;headerlink&quot; title=&quot;浏览器篇&quot;&gt;&lt;/a&gt;浏览器篇&lt;/h3&gt;&lt;p&gt;开发浏览器: Chorme（不用解释）&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;一定要先清缓存！清缓存！清缓存！ 重要的说三
      
    
    </summary>
    
      <category term="php" scheme="http://tecknight.xyz/categories/php/"/>
    
    
      <category term="php" scheme="http://tecknight.xyz/tags/php/"/>
    
      <category term="Laravel" scheme="http://tecknight.xyz/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Vue 学习总结</title>
    <link href="http://tecknight.xyz/2017/01/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://tecknight.xyz/2017/01/25/Vue学习笔记/</id>
    <published>2017-01-25T07:50:32.000Z</published>
    <updated>2017-03-22T14:57:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>##将数据渲染进DOM元素</p><ol><li>&#123;&#123;message&#125;&#125;</li><li>v-bind:属性= (也可写作 :属性=)</li></ol><p>##常用语句<br>判断  <code>v-if</code></p><p>循环  <code>v-for=&quot;todo in todos&quot;</code></p><p>按钮 <code>v-on:click=&quot;函数名&quot;</code> (也可写作 @click=)</p><p>表单数据和应用数据双向绑定 <code>v-model=&quot;数据名&quot;</code></p><p>##组件</p><pre class=" language-javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'todo-item'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// The todo-item component now accepts a</span>  <span class="token comment" spellcheck="true">// "prop", which is like a custom attribute. </span>  <span class="token comment" spellcheck="true">// This prop is called todo. </span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'todo'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    template<span class="token punctuation">:</span> <span class="token string">'&lt;li>{{ todo.text }}&lt;/li>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li><p>props作为子组件的接口，接收父类的数据，同时解耦</p></li><li><p>组件可以作为自定义标签在HTML中使用</p></li><li><p>所有的 Vue.js 组件其实都是被扩展的 Vue 实例</p></li></ul><p>实质上是一个预定义的Vue实例，在实例app中，app相当于父类，而组件相当于是app中的子类，父类的数据可以通过<code>v-bind:字段名</code><br>的方式将父类作用域中的数据传入子类组件中</p><p>####用Vue创建的应用的大致结构</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-nav</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-nav</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-view</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-sidebar</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-sidebar</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-content</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-content</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>###创建实例</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 选项</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>传入的选项对象包括：</p><ul><li><p>数据</p></li><li><p>模板</p></li><li><p>挂载元素</p></li><li><p>方法</p></li><li><p>生命周期钩子</p></li></ul><p>###属性和方法</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#example'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> data<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//vm.a === data.a</span>vm<span class="token punctuation">.</span>$data <span class="token operator">===</span> data <span class="token comment" spellcheck="true">// -> true</span>vm<span class="token punctuation">.</span>$el <span class="token operator">===</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -> true</span><span class="token comment" spellcheck="true">// $watch 是一个实例方法</span>vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 这个回调将在 vm.a  改变后调用</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>#####注意：</p><ul><li><p>所有代理的属性都是响应的，添加新的属性时不会触发视图的更新</p></li><li><p>钩子的<code>this</code>代表着调用它的实例</p></li></ul><p>###插值</p><p>####文本</p><ol><li><p>用双大括号<code>&amp;#123;&amp;#123;数据对象 &amp;#124; 过滤器&amp;#125;&amp;#125;</code></p><p> 注意：</p><p> 双大括号中也可以是JS表达式可对数据进行运算</p><p> 渲染结果解释为纯文本</p><p> 若要输出HTML，需要在div中设置</p><p> <code>&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt;</code></p></li></ol><p>##计算属性<br>用于将复杂的数据运算包含于实例的初始化中</p><p>作为其中一个选项对象：</p><pre class=" language-javascript"><code class="language-javascript">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// a computed getter</span>    reversedMessage<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// this points to the vm instance</span>      <span class="token keyword">return</span>                  <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>reversedMessage作为计算过后的新属性，直接用双大括号进行解释即可得到计算的最终结果</p><p>####计算缓存与Method的区别<br>好处：当数据的值不改变的时候，依然会使用计算缓存而无需像调用Method那样重新计算<br>前提：计算缓存的使用必须要基于相关依赖，像Date.now()就不行</p><p>####计算缓存与$watch</p><p>在数据变动时，可以优先考虑用计算缓存，而并非watch回调</p><p>注意:计算属性默认为getter，也可设置为setter,setter在内部赋值的时候会被调用</p><hr><p>##观察者 Watchers</p><p>当数据值变动时，相对于计算属性，更加的通用，执行异步操作(ajax访问API)或需要响应不断变化昂贵的数据操作时这很有用,例如限制访问API的频率</p><p>##Class 与 Style绑定</p><p>###绑定HTML Class<br>语法：<code>v-bind:class={class1:布尔变量,class2...}</code></p><p>class还可以是数据对象,甚至是计算属性！</p><p>#####通过控制布尔变量可以使元素的class动态切换</p><p><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;</code></p><p>###绑定内联样式</p><p><code>v-bind:style=&quot;{ color: mycolor}&quot;</code> mycolor在data中定义</p><p>复杂内联样式推荐绑定styleObject对象</p><pre class=" language-javascript"><code class="language-javascript">data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  styleObject<span class="token punctuation">:</span> <span class="token punctuation">{</span>    color<span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span>    fontSize<span class="token punctuation">:</span> <span class="token string">'13px'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>##条件渲染<br>判断一个标签的输出 <code>v-if=&quot;ok&quot;</code> ok值决定是否显示</p><p>判断一块标签的显示 用template元素作为包装元素，下面为根据需要显示的标签块</p><p><code>v-else</code>可以和<code>v-if</code>和<code>v-show</code>一起使用</p><p><code>v-show</code>专门用于对渲染元素的CSS属性，且不支持<code>&lt;template&gt;</code>标签</p><p>####v-if 和 v-show比较</p><p>频繁切换使用的用v-show,条件不大可能改变的v-if</p><p>##列表渲染</p><p><code>&lt;template v-for=&quot;&quot;&gt;</code></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(value, key, index) in object<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  {{ index }}. {{ key }} : {{ value }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>index索引，key键，value值</p><p>##key(未完)</p><p>作用：让Vue标识出节点的身份，检测数组元素的突变<br>用法：v-bind:key=”item.id”</p><p>##数组更新检测</p><p>变异方法：一组用来观察数组的方法，可以触发视图更新</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>非变异方法：不会改变原始数组的数据，但是会返回新的数组，适用于不想改变原值的情况</p><ul><li>filter()</li><li>concat()</li><li>slice()</li></ul><p>##事件处理器</p><p>###监听事件</p><p><code>v-on:</code>指令，例如点击<code>v-on:click=&quot;触发方法名&quot;</code></p><p>###内联事件处理<br><code>&lt;button v-on:click=&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;/button&gt;</code><br>say方法名(传入的参数)</p><p>如果要访问DOM原生对象,传入的参数要有 特殊符号美元+event</p><p>###事件修饰符<br>添加在click和submit后</p><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li></ul><p>###按键修饰符<br><code>&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</code><br>13表示键值，该按键按下后会触发submit</p><p><code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code></p><p>达到直接在HTML中监听事件的效果</p><p>##表单控件绑定<br>略</p><p>##组件</p><p>###注册全局组件</p><p><code>Vue.component(&#39;my-component&#39;, {  选项})</code>  父组件<br>``</p><p>必须先注册组件，然后再初始化父实例，才能在父实例中使用组件自定义标签</p><p>###注册局部组件</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Child <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>A custom component!&lt;/div>'</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// &lt;my-component> 将只在父模板可用</span>    <span class="token string">'my-component'</span><span class="token punctuation">:</span> Child  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>子组件</p><p>###data</p><p>注意：组件的data必须是函数！通过return的方式将data传入组件绑定的元素中</p><p>意义：类似接口解耦，使得同一个data在不同的组件中都能有自己不同的状态！</p><p>###传递数据<br>父–&gt;子 props:[‘字段名’]</p><p>动态绑定 <code>v-bind:字段名=&quot;父数据名&quot;</code><br><code>&lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</code></p><p>###props验证</p><pre class=" language-javascript"><code class="language-javascript">propB<span class="token punctuation">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Number<span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 必须且是字符串</span>    propC<span class="token punctuation">:</span> <span class="token punctuation">{</span>      type<span class="token punctuation">:</span> String<span class="token punctuation">,</span>      required<span class="token punctuation">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 数字，有默认值</span>    propD<span class="token punctuation">:</span> <span class="token punctuation">{</span>      type<span class="token punctuation">:</span> Number<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token number">100</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 数组／对象的默认值应当由一个工厂函数返回</span></code></pre><p>###组件v-model数据双向绑定<br>表单自定义绑定：</p><p>1.绑定value</p><p>2.有新的value时触发input事件</p><p>###非父子组件的通信<br>须使用一个空vue实例来当中央</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> bus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 触发组件 A 中的事件</span>bus<span class="token punctuation">.</span><span class="token function">美元emit</span><span class="token punctuation">(</span><span class="token string">'id-selected'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 在组件 B 创建的钩子中监听事件</span>bus<span class="token punctuation">.</span><span class="token function">美on</span><span class="token punctuation">(</span><span class="token string">'id-selected'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>###内容分发</p><p>绑定子组件内的指令到一个组件的根节点，必须在子组件的内部定义模板时进行绑定</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-component</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is some original content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is some more original content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-component</span><span class="token punctuation">></span></span></code></pre><p>在父模板中放入子组件的标签，其中的内容将会被安插到子组件的<code>&lt;slot&gt;&lt;/slot&gt;</code>标签中</p><p>slot=”名称”  可以定义名字以标识父插入子的何处</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##将数据渲染进DOM元素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;#123;&amp;#123;message&amp;#125;&amp;#125;&lt;/li&gt;
&lt;li&gt;v-bind:属性= (也可写作 :属性=)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##常用语句&lt;br&gt;判断  &lt;code&gt;v-if&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="Vue" scheme="http://tecknight.xyz/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://tecknight.xyz/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Sass语法点总结</title>
    <link href="http://tecknight.xyz/2016/12/03/Sass%E8%AF%AD%E6%B3%95%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://tecknight.xyz/2016/12/03/Sass语法点总结/</id>
    <published>2016-12-03T11:43:37.000Z</published>
    <updated>2017-03-22T14:33:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类似PHP，Sass提供了一种类似PHP的感觉，声明变量的方式与PHP相同，赋值方式则与CSS类似-变量名：值"><a href="#类似PHP，Sass提供了一种类似PHP的感觉，声明变量的方式与PHP相同，赋值方式则与CSS类似-变量名：值" class="headerlink" title="类似PHP，Sass提供了一种类似PHP的感觉，声明变量的方式与PHP相同，赋值方式则与CSS类似$变量名：值;"></a>类似PHP，Sass提供了一种类似PHP的感觉，声明变量的方式与PHP相同，赋值方式则与CSS类似<code>$变量名：值;</code></h4><h3 id="常用关键词"><a href="#常用关键词" class="headerlink" title="常用关键词"></a>常用关键词</h3><ol><li><p>@import</p><p> 引入sass模块</p></li><li><p>@include</p><p> 引入mixin函数</p></li><li><p>@mixin</p><p> 声明函数 </p></li><li><p>@extends</p><p> 继承某CSS类的样式(存在问题，尽量不使用)</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类似PHP，Sass提供了一种类似PHP的感觉，声明变量的方式与PHP相同，赋值方式则与CSS类似-变量名：值&quot;&gt;&lt;a href=&quot;#类似PHP，Sass提供了一种类似PHP的感觉，声明变量的方式与PHP相同，赋值方式则与CSS类似-变量名：值&quot; class=&quot;h
      
    
    </summary>
    
      <category term="css" scheme="http://tecknight.xyz/categories/css/"/>
    
    
      <category term="css" scheme="http://tecknight.xyz/tags/css/"/>
    
      <category term="Sass" scheme="http://tecknight.xyz/tags/Sass/"/>
    
  </entry>
  
  <entry>
    <title>Sass之CSS模块化</title>
    <link href="http://tecknight.xyz/2016/12/03/Sass%E4%B9%8BCSS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://tecknight.xyz/2016/12/03/Sass之CSS模块化/</id>
    <published>2016-12-03T11:43:37.000Z</published>
    <updated>2017-03-22T14:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般在项目目录中我们会建一个sass文件夹，内容一般为partials文件夹还有一个app.scss文件，partials文件夹存放我们的CSS模块，app.scss中进行import</p><p><code>@import &#39;partials/temp;&#39;</code></p><p>partials文件夹中的模块scss文件最前面必须加上下划线 _</p><p>使得sass在监听并编译成css的时候能够将模块编译到一起而不是生成多个css文件</p><h2 id="CSS模块常用目录结构"><a href="#CSS模块常用目录结构" class="headerlink" title="CSS模块常用目录结构"></a>CSS模块常用目录结构</h2><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><ol><li>base    基本样式<ul><li>variable 变量</li><li>typography</li><li>base 例如:wrapper居中CSS</li></ul></li><li>layout        布局<ul><li>nav    </li><li>hero        </li><li>footer    </li><li>layout</li></ul></li><li>component    组件<ul><li>button </li><li>schedule</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般在项目目录中我们会建一个sass文件夹，内容一般为partials文件夹还有一个app.scss文件，partials文件夹存放我们的CSS模块，app.scss中进行import&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@import &amp;#39;partials/temp;&amp;#39
      
    
    </summary>
    
      <category term="css" scheme="http://tecknight.xyz/categories/css/"/>
    
    
      <category term="css" scheme="http://tecknight.xyz/tags/css/"/>
    
      <category term="Sass" scheme="http://tecknight.xyz/tags/Sass/"/>
    
  </entry>
  
</feed>
